// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  academy: (where?: AcademyWhereInput) => Promise<boolean>;
  clan: (where?: ClanWhereInput) => Promise<boolean>;
  form: (where?: FormWhereInput) => Promise<boolean>;
  player: (where?: PlayerWhereInput) => Promise<boolean>;
  poule: (where?: PouleWhereInput) => Promise<boolean>;
  school: (where?: SchoolWhereInput) => Promise<boolean>;
  tournament: (where?: TournamentWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  academy: (where: AcademyWhereUniqueInput) => AcademyNullablePromise;
  academies: (args?: {
    where?: AcademyWhereInput;
    orderBy?: AcademyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Academy>;
  academiesConnection: (args?: {
    where?: AcademyWhereInput;
    orderBy?: AcademyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AcademyConnectionPromise;
  clan: (where: ClanWhereUniqueInput) => ClanNullablePromise;
  clans: (args?: {
    where?: ClanWhereInput;
    orderBy?: ClanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Clan>;
  clansConnection: (args?: {
    where?: ClanWhereInput;
    orderBy?: ClanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClanConnectionPromise;
  form: (where: FormWhereUniqueInput) => FormNullablePromise;
  forms: (args?: {
    where?: FormWhereInput;
    orderBy?: FormOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Form>;
  formsConnection: (args?: {
    where?: FormWhereInput;
    orderBy?: FormOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FormConnectionPromise;
  player: (where: PlayerWhereUniqueInput) => PlayerNullablePromise;
  players: (args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Player>;
  playersConnection: (args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlayerConnectionPromise;
  poule: (where: PouleWhereUniqueInput) => PouleNullablePromise;
  poules: (args?: {
    where?: PouleWhereInput;
    orderBy?: PouleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Poule>;
  poulesConnection: (args?: {
    where?: PouleWhereInput;
    orderBy?: PouleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PouleConnectionPromise;
  school: (where: SchoolWhereUniqueInput) => SchoolNullablePromise;
  schools: (args?: {
    where?: SchoolWhereInput;
    orderBy?: SchoolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<School>;
  schoolsConnection: (args?: {
    where?: SchoolWhereInput;
    orderBy?: SchoolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SchoolConnectionPromise;
  tournament: (where: TournamentWhereUniqueInput) => TournamentNullablePromise;
  tournaments: (args?: {
    where?: TournamentWhereInput;
    orderBy?: TournamentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tournament>;
  tournamentsConnection: (args?: {
    where?: TournamentWhereInput;
    orderBy?: TournamentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TournamentConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAcademy: (data: AcademyCreateInput) => AcademyPromise;
  updateAcademy: (args: {
    data: AcademyUpdateInput;
    where: AcademyWhereUniqueInput;
  }) => AcademyPromise;
  updateManyAcademies: (args: {
    data: AcademyUpdateManyMutationInput;
    where?: AcademyWhereInput;
  }) => BatchPayloadPromise;
  upsertAcademy: (args: {
    where: AcademyWhereUniqueInput;
    create: AcademyCreateInput;
    update: AcademyUpdateInput;
  }) => AcademyPromise;
  deleteAcademy: (where: AcademyWhereUniqueInput) => AcademyPromise;
  deleteManyAcademies: (where?: AcademyWhereInput) => BatchPayloadPromise;
  createClan: (data: ClanCreateInput) => ClanPromise;
  updateClan: (args: {
    data: ClanUpdateInput;
    where: ClanWhereUniqueInput;
  }) => ClanPromise;
  updateManyClans: (args: {
    data: ClanUpdateManyMutationInput;
    where?: ClanWhereInput;
  }) => BatchPayloadPromise;
  upsertClan: (args: {
    where: ClanWhereUniqueInput;
    create: ClanCreateInput;
    update: ClanUpdateInput;
  }) => ClanPromise;
  deleteClan: (where: ClanWhereUniqueInput) => ClanPromise;
  deleteManyClans: (where?: ClanWhereInput) => BatchPayloadPromise;
  createForm: (data: FormCreateInput) => FormPromise;
  updateForm: (args: {
    data: FormUpdateInput;
    where: FormWhereUniqueInput;
  }) => FormPromise;
  updateManyForms: (args: {
    data: FormUpdateManyMutationInput;
    where?: FormWhereInput;
  }) => BatchPayloadPromise;
  upsertForm: (args: {
    where: FormWhereUniqueInput;
    create: FormCreateInput;
    update: FormUpdateInput;
  }) => FormPromise;
  deleteForm: (where: FormWhereUniqueInput) => FormPromise;
  deleteManyForms: (where?: FormWhereInput) => BatchPayloadPromise;
  createPlayer: (data: PlayerCreateInput) => PlayerPromise;
  updatePlayer: (args: {
    data: PlayerUpdateInput;
    where: PlayerWhereUniqueInput;
  }) => PlayerPromise;
  updateManyPlayers: (args: {
    data: PlayerUpdateManyMutationInput;
    where?: PlayerWhereInput;
  }) => BatchPayloadPromise;
  upsertPlayer: (args: {
    where: PlayerWhereUniqueInput;
    create: PlayerCreateInput;
    update: PlayerUpdateInput;
  }) => PlayerPromise;
  deletePlayer: (where: PlayerWhereUniqueInput) => PlayerPromise;
  deleteManyPlayers: (where?: PlayerWhereInput) => BatchPayloadPromise;
  createPoule: (data: PouleCreateInput) => PoulePromise;
  updatePoule: (args: {
    data: PouleUpdateInput;
    where: PouleWhereUniqueInput;
  }) => PoulePromise;
  updateManyPoules: (args: {
    data: PouleUpdateManyMutationInput;
    where?: PouleWhereInput;
  }) => BatchPayloadPromise;
  upsertPoule: (args: {
    where: PouleWhereUniqueInput;
    create: PouleCreateInput;
    update: PouleUpdateInput;
  }) => PoulePromise;
  deletePoule: (where: PouleWhereUniqueInput) => PoulePromise;
  deleteManyPoules: (where?: PouleWhereInput) => BatchPayloadPromise;
  createSchool: (data: SchoolCreateInput) => SchoolPromise;
  updateSchool: (args: {
    data: SchoolUpdateInput;
    where: SchoolWhereUniqueInput;
  }) => SchoolPromise;
  updateManySchools: (args: {
    data: SchoolUpdateManyMutationInput;
    where?: SchoolWhereInput;
  }) => BatchPayloadPromise;
  upsertSchool: (args: {
    where: SchoolWhereUniqueInput;
    create: SchoolCreateInput;
    update: SchoolUpdateInput;
  }) => SchoolPromise;
  deleteSchool: (where: SchoolWhereUniqueInput) => SchoolPromise;
  deleteManySchools: (where?: SchoolWhereInput) => BatchPayloadPromise;
  createTournament: (data: TournamentCreateInput) => TournamentPromise;
  updateTournament: (args: {
    data: TournamentUpdateInput;
    where: TournamentWhereUniqueInput;
  }) => TournamentPromise;
  updateManyTournaments: (args: {
    data: TournamentUpdateManyMutationInput;
    where?: TournamentWhereInput;
  }) => BatchPayloadPromise;
  upsertTournament: (args: {
    where: TournamentWhereUniqueInput;
    create: TournamentCreateInput;
    update: TournamentUpdateInput;
  }) => TournamentPromise;
  deleteTournament: (where: TournamentWhereUniqueInput) => TournamentPromise;
  deleteManyTournaments: (where?: TournamentWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  academy: (
    where?: AcademySubscriptionWhereInput
  ) => AcademySubscriptionPayloadSubscription;
  clan: (
    where?: ClanSubscriptionWhereInput
  ) => ClanSubscriptionPayloadSubscription;
  form: (
    where?: FormSubscriptionWhereInput
  ) => FormSubscriptionPayloadSubscription;
  player: (
    where?: PlayerSubscriptionWhereInput
  ) => PlayerSubscriptionPayloadSubscription;
  poule: (
    where?: PouleSubscriptionWhereInput
  ) => PouleSubscriptionPayloadSubscription;
  school: (
    where?: SchoolSubscriptionWhereInput
  ) => SchoolSubscriptionPayloadSubscription;
  tournament: (
    where?: TournamentSubscriptionWhereInput
  ) => TournamentSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type FormOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type PoulesType = "POSITIONING" | "QUALIFICATION";

export type AcademyOrderByInput =
  | "country_ASC"
  | "country_DESC"
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type SchoolOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type ClanOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type PlayerOrderByInput =
  | "familyName_ASC"
  | "familyName_DESC"
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "nickname_ASC"
  | "nickname_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PouleOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type TournamentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "poulesType_ASC"
  | "poulesType_DESC";

export type UserOrderByInput =
  | "email_ASC"
  | "email_DESC"
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "password_ASC"
  | "password_DESC";

export interface SchoolUpdateManyWithoutAcademyInput {
  create?: Maybe<
    SchoolCreateWithoutAcademyInput[] | SchoolCreateWithoutAcademyInput
  >;
  delete?: Maybe<SchoolWhereUniqueInput[] | SchoolWhereUniqueInput>;
  connect?: Maybe<SchoolWhereUniqueInput[] | SchoolWhereUniqueInput>;
  set?: Maybe<SchoolWhereUniqueInput[] | SchoolWhereUniqueInput>;
  disconnect?: Maybe<SchoolWhereUniqueInput[] | SchoolWhereUniqueInput>;
  update?: Maybe<
    | SchoolUpdateWithWhereUniqueWithoutAcademyInput[]
    | SchoolUpdateWithWhereUniqueWithoutAcademyInput
  >;
  upsert?: Maybe<
    | SchoolUpsertWithWhereUniqueWithoutAcademyInput[]
    | SchoolUpsertWithWhereUniqueWithoutAcademyInput
  >;
  deleteMany?: Maybe<SchoolScalarWhereInput[] | SchoolScalarWhereInput>;
  updateMany?: Maybe<
    | SchoolUpdateManyWithWhereNestedInput[]
    | SchoolUpdateManyWithWhereNestedInput
  >;
}

export type AcademyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface SchoolUpsertWithWhereUniqueWithoutAcademyInput {
  where: SchoolWhereUniqueInput;
  update: SchoolUpdateWithoutAcademyDataInput;
  create: SchoolCreateWithoutAcademyInput;
}

export interface TournamentWhereInput {
  createdBy?: Maybe<UserWhereInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  players_every?: Maybe<PlayerWhereInput>;
  players_some?: Maybe<PlayerWhereInput>;
  players_none?: Maybe<PlayerWhereInput>;
  poules_every?: Maybe<PouleWhereInput>;
  poules_some?: Maybe<PouleWhereInput>;
  poules_none?: Maybe<PouleWhereInput>;
  poulesType?: Maybe<PoulesType>;
  poulesType_not?: Maybe<PoulesType>;
  poulesType_in?: Maybe<PoulesType[] | PoulesType>;
  poulesType_not_in?: Maybe<PoulesType[] | PoulesType>;
  AND?: Maybe<TournamentWhereInput[] | TournamentWhereInput>;
  OR?: Maybe<TournamentWhereInput[] | TournamentWhereInput>;
  NOT?: Maybe<TournamentWhereInput[] | TournamentWhereInput>;
}

export interface SchoolScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<SchoolScalarWhereInput[] | SchoolScalarWhereInput>;
  OR?: Maybe<SchoolScalarWhereInput[] | SchoolScalarWhereInput>;
  NOT?: Maybe<SchoolScalarWhereInput[] | SchoolScalarWhereInput>;
}

export interface FormWhereInput {
  createdBy?: Maybe<UserWhereInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<FormWhereInput[] | FormWhereInput>;
  OR?: Maybe<FormWhereInput[] | FormWhereInput>;
  NOT?: Maybe<FormWhereInput[] | FormWhereInput>;
}

export interface SchoolUpdateManyWithWhereNestedInput {
  where: SchoolScalarWhereInput;
  data: SchoolUpdateManyDataInput;
}

export interface PlayerWhereInput {
  clan?: Maybe<ClanWhereInput>;
  createdBy?: Maybe<UserWhereInput>;
  familyName?: Maybe<String>;
  familyName_not?: Maybe<String>;
  familyName_in?: Maybe<String[] | String>;
  familyName_not_in?: Maybe<String[] | String>;
  familyName_lt?: Maybe<String>;
  familyName_lte?: Maybe<String>;
  familyName_gt?: Maybe<String>;
  familyName_gte?: Maybe<String>;
  familyName_contains?: Maybe<String>;
  familyName_not_contains?: Maybe<String>;
  familyName_starts_with?: Maybe<String>;
  familyName_not_starts_with?: Maybe<String>;
  familyName_ends_with?: Maybe<String>;
  familyName_not_ends_with?: Maybe<String>;
  forms_every?: Maybe<FormWhereInput>;
  forms_some?: Maybe<FormWhereInput>;
  forms_none?: Maybe<FormWhereInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  nickname?: Maybe<String>;
  nickname_not?: Maybe<String>;
  nickname_in?: Maybe<String[] | String>;
  nickname_not_in?: Maybe<String[] | String>;
  nickname_lt?: Maybe<String>;
  nickname_lte?: Maybe<String>;
  nickname_gt?: Maybe<String>;
  nickname_gte?: Maybe<String>;
  nickname_contains?: Maybe<String>;
  nickname_not_contains?: Maybe<String>;
  nickname_starts_with?: Maybe<String>;
  nickname_not_starts_with?: Maybe<String>;
  nickname_ends_with?: Maybe<String>;
  nickname_not_ends_with?: Maybe<String>;
  poules_every?: Maybe<PouleWhereInput>;
  poules_some?: Maybe<PouleWhereInput>;
  poules_none?: Maybe<PouleWhereInput>;
  tournaments_every?: Maybe<TournamentWhereInput>;
  tournaments_some?: Maybe<TournamentWhereInput>;
  tournaments_none?: Maybe<TournamentWhereInput>;
  AND?: Maybe<PlayerWhereInput[] | PlayerWhereInput>;
  OR?: Maybe<PlayerWhereInput[] | PlayerWhereInput>;
  NOT?: Maybe<PlayerWhereInput[] | PlayerWhereInput>;
}

export interface SchoolUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface ClanWhereInput {
  createdBy?: Maybe<UserWhereInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  players_every?: Maybe<PlayerWhereInput>;
  players_some?: Maybe<PlayerWhereInput>;
  players_none?: Maybe<PlayerWhereInput>;
  school?: Maybe<SchoolWhereInput>;
  AND?: Maybe<ClanWhereInput[] | ClanWhereInput>;
  OR?: Maybe<ClanWhereInput[] | ClanWhereInput>;
  NOT?: Maybe<ClanWhereInput[] | ClanWhereInput>;
}

export interface AcademyUpsertWithWhereUniqueWithoutCreatedByInput {
  where: AcademyWhereUniqueInput;
  update: AcademyUpdateWithoutCreatedByDataInput;
  create: AcademyCreateWithoutCreatedByInput;
}

export interface SchoolWhereInput {
  academy?: Maybe<AcademyWhereInput>;
  clans_every?: Maybe<ClanWhereInput>;
  clans_some?: Maybe<ClanWhereInput>;
  clans_none?: Maybe<ClanWhereInput>;
  createdBy?: Maybe<UserWhereInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<SchoolWhereInput[] | SchoolWhereInput>;
  OR?: Maybe<SchoolWhereInput[] | SchoolWhereInput>;
  NOT?: Maybe<SchoolWhereInput[] | SchoolWhereInput>;
}

export interface AcademyScalarWhereInput {
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<AcademyScalarWhereInput[] | AcademyScalarWhereInput>;
  OR?: Maybe<AcademyScalarWhereInput[] | AcademyScalarWhereInput>;
  NOT?: Maybe<AcademyScalarWhereInput[] | AcademyScalarWhereInput>;
}

export interface UserWhereInput {
  academies_every?: Maybe<AcademyWhereInput>;
  academies_some?: Maybe<AcademyWhereInput>;
  academies_none?: Maybe<AcademyWhereInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  schools_every?: Maybe<SchoolWhereInput>;
  schools_some?: Maybe<SchoolWhereInput>;
  schools_none?: Maybe<SchoolWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface AcademyUpdateManyWithWhereNestedInput {
  where: AcademyScalarWhereInput;
  data: AcademyUpdateManyDataInput;
}

export interface AcademyWhereInput {
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  schools_every?: Maybe<SchoolWhereInput>;
  schools_some?: Maybe<SchoolWhereInput>;
  schools_none?: Maybe<SchoolWhereInput>;
  AND?: Maybe<AcademyWhereInput[] | AcademyWhereInput>;
  OR?: Maybe<AcademyWhereInput[] | AcademyWhereInput>;
  NOT?: Maybe<AcademyWhereInput[] | AcademyWhereInput>;
}

export interface SchoolUpdateManyWithoutCreatedByInput {
  create?: Maybe<
    SchoolCreateWithoutCreatedByInput[] | SchoolCreateWithoutCreatedByInput
  >;
  delete?: Maybe<SchoolWhereUniqueInput[] | SchoolWhereUniqueInput>;
  connect?: Maybe<SchoolWhereUniqueInput[] | SchoolWhereUniqueInput>;
  set?: Maybe<SchoolWhereUniqueInput[] | SchoolWhereUniqueInput>;
  disconnect?: Maybe<SchoolWhereUniqueInput[] | SchoolWhereUniqueInput>;
  update?: Maybe<
    | SchoolUpdateWithWhereUniqueWithoutCreatedByInput[]
    | SchoolUpdateWithWhereUniqueWithoutCreatedByInput
  >;
  upsert?: Maybe<
    | SchoolUpsertWithWhereUniqueWithoutCreatedByInput[]
    | SchoolUpsertWithWhereUniqueWithoutCreatedByInput
  >;
  deleteMany?: Maybe<SchoolScalarWhereInput[] | SchoolScalarWhereInput>;
  updateMany?: Maybe<
    | SchoolUpdateManyWithWhereNestedInput[]
    | SchoolUpdateManyWithWhereNestedInput
  >;
}

export interface TournamentUpdateManyDataInput {
  name?: Maybe<String>;
  poulesType?: Maybe<PoulesType>;
}

export interface SchoolUpdateWithWhereUniqueWithoutCreatedByInput {
  where: SchoolWhereUniqueInput;
  data: SchoolUpdateWithoutCreatedByDataInput;
}

export interface AcademyUpdateManyDataInput {
  country?: Maybe<String>;
  name?: Maybe<String>;
}

export interface SchoolUpdateWithoutCreatedByDataInput {
  academy?: Maybe<AcademyUpdateOneRequiredWithoutSchoolsInput>;
  clans?: Maybe<ClanUpdateManyWithoutSchoolInput>;
  name?: Maybe<String>;
}

export interface TournamentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TournamentWhereInput>;
  AND?: Maybe<
    TournamentSubscriptionWhereInput[] | TournamentSubscriptionWhereInput
  >;
  OR?: Maybe<
    TournamentSubscriptionWhereInput[] | TournamentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TournamentSubscriptionWhereInput[] | TournamentSubscriptionWhereInput
  >;
}

export interface AcademyUpdateOneRequiredWithoutSchoolsInput {
  create?: Maybe<AcademyCreateWithoutSchoolsInput>;
  update?: Maybe<AcademyUpdateWithoutSchoolsDataInput>;
  upsert?: Maybe<AcademyUpsertWithoutSchoolsInput>;
  connect?: Maybe<AcademyWhereUniqueInput>;
}

export interface PouleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PouleWhereInput>;
  AND?: Maybe<PouleSubscriptionWhereInput[] | PouleSubscriptionWhereInput>;
  OR?: Maybe<PouleSubscriptionWhereInput[] | PouleSubscriptionWhereInput>;
  NOT?: Maybe<PouleSubscriptionWhereInput[] | PouleSubscriptionWhereInput>;
}

export interface AcademyUpdateWithoutSchoolsDataInput {
  country?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneWithoutAcademiesInput>;
  name?: Maybe<String>;
}

export type ClanWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AcademyUpsertWithoutSchoolsInput {
  update: AcademyUpdateWithoutSchoolsDataInput;
  create: AcademyCreateWithoutSchoolsInput;
}

export interface ClanSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClanWhereInput>;
  AND?: Maybe<ClanSubscriptionWhereInput[] | ClanSubscriptionWhereInput>;
  OR?: Maybe<ClanSubscriptionWhereInput[] | ClanSubscriptionWhereInput>;
  NOT?: Maybe<ClanSubscriptionWhereInput[] | ClanSubscriptionWhereInput>;
}

export interface ClanUpdateManyWithoutSchoolInput {
  create?: Maybe<ClanCreateWithoutSchoolInput[] | ClanCreateWithoutSchoolInput>;
  delete?: Maybe<ClanWhereUniqueInput[] | ClanWhereUniqueInput>;
  connect?: Maybe<ClanWhereUniqueInput[] | ClanWhereUniqueInput>;
  set?: Maybe<ClanWhereUniqueInput[] | ClanWhereUniqueInput>;
  disconnect?: Maybe<ClanWhereUniqueInput[] | ClanWhereUniqueInput>;
  update?: Maybe<
    | ClanUpdateWithWhereUniqueWithoutSchoolInput[]
    | ClanUpdateWithWhereUniqueWithoutSchoolInput
  >;
  upsert?: Maybe<
    | ClanUpsertWithWhereUniqueWithoutSchoolInput[]
    | ClanUpsertWithWhereUniqueWithoutSchoolInput
  >;
  deleteMany?: Maybe<ClanScalarWhereInput[] | ClanScalarWhereInput>;
  updateMany?: Maybe<
    ClanUpdateManyWithWhereNestedInput[] | ClanUpdateManyWithWhereNestedInput
  >;
}

export type FormWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ClanUpdateWithWhereUniqueWithoutSchoolInput {
  where: ClanWhereUniqueInput;
  data: ClanUpdateWithoutSchoolDataInput;
}

export interface UserUpdateInput {
  academies?: Maybe<AcademyUpdateManyWithoutCreatedByInput>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  schools?: Maybe<SchoolUpdateManyWithoutCreatedByInput>;
}

export interface ClanUpdateWithoutSchoolDataInput {
  createdBy?: Maybe<UserUpdateOneInput>;
  name?: Maybe<String>;
  players?: Maybe<PlayerUpdateManyWithoutClanInput>;
}

export type PlayerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface TournamentCreateInput {
  createdBy?: Maybe<UserCreateOneInput>;
  id?: Maybe<ID_Input>;
  name: String;
  players?: Maybe<PlayerCreateManyWithoutTournamentsInput>;
  poules?: Maybe<PouleCreateManyWithoutTournamentInput>;
  poulesType: PoulesType;
}

export interface UserUpdateDataInput {
  academies?: Maybe<AcademyUpdateManyWithoutCreatedByInput>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  schools?: Maybe<SchoolUpdateManyWithoutCreatedByInput>;
}

export type PouleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AcademyUpdateManyWithoutCreatedByInput {
  create?: Maybe<
    AcademyCreateWithoutCreatedByInput[] | AcademyCreateWithoutCreatedByInput
  >;
  delete?: Maybe<AcademyWhereUniqueInput[] | AcademyWhereUniqueInput>;
  connect?: Maybe<AcademyWhereUniqueInput[] | AcademyWhereUniqueInput>;
  set?: Maybe<AcademyWhereUniqueInput[] | AcademyWhereUniqueInput>;
  disconnect?: Maybe<AcademyWhereUniqueInput[] | AcademyWhereUniqueInput>;
  update?: Maybe<
    | AcademyUpdateWithWhereUniqueWithoutCreatedByInput[]
    | AcademyUpdateWithWhereUniqueWithoutCreatedByInput
  >;
  upsert?: Maybe<
    | AcademyUpsertWithWhereUniqueWithoutCreatedByInput[]
    | AcademyUpsertWithWhereUniqueWithoutCreatedByInput
  >;
  deleteMany?: Maybe<AcademyScalarWhereInput[] | AcademyScalarWhereInput>;
  updateMany?: Maybe<
    | AcademyUpdateManyWithWhereNestedInput[]
    | AcademyUpdateManyWithWhereNestedInput
  >;
}

export interface SchoolCreateInput {
  academy: AcademyCreateOneWithoutSchoolsInput;
  clans?: Maybe<ClanCreateManyWithoutSchoolInput>;
  createdBy?: Maybe<UserCreateOneWithoutSchoolsInput>;
  id?: Maybe<ID_Input>;
  name: String;
}

export interface AcademyUpdateWithWhereUniqueWithoutCreatedByInput {
  where: AcademyWhereUniqueInput;
  data: AcademyUpdateWithoutCreatedByDataInput;
}

export type SchoolWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AcademyUpdateWithoutCreatedByDataInput {
  country?: Maybe<String>;
  name?: Maybe<String>;
  schools?: Maybe<SchoolUpdateManyWithoutAcademyInput>;
}

export interface PouleCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  players?: Maybe<PlayerCreateManyWithoutPoulesInput>;
  tournament: TournamentCreateOneWithoutPoulesInput;
}

export interface AcademyUpdateManyMutationInput {
  country?: Maybe<String>;
  name?: Maybe<String>;
}

export type TournamentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SchoolUpdateWithWhereUniqueWithoutAcademyInput {
  where: SchoolWhereUniqueInput;
  data: SchoolUpdateWithoutAcademyDataInput;
}

export interface PlayerCreateInput {
  clan: ClanCreateOneWithoutPlayersInput;
  createdBy?: Maybe<UserCreateOneInput>;
  familyName: String;
  forms?: Maybe<FormCreateManyInput>;
  id?: Maybe<ID_Input>;
  name: String;
  nickname: String;
  poules?: Maybe<PouleCreateManyWithoutPlayersInput>;
  tournaments?: Maybe<TournamentCreateManyWithoutPlayersInput>;
}

export interface SchoolUpdateWithoutAcademyDataInput {
  clans?: Maybe<ClanUpdateManyWithoutSchoolInput>;
  createdBy?: Maybe<UserUpdateOneWithoutSchoolsInput>;
  name?: Maybe<String>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  email: Maybe<String>;
  id?: Maybe<ID_Input>;
}>;

export interface UserUpdateOneWithoutSchoolsInput {
  create?: Maybe<UserCreateWithoutSchoolsInput>;
  update?: Maybe<UserUpdateWithoutSchoolsDataInput>;
  upsert?: Maybe<UserUpsertWithoutSchoolsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ClanUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface UserUpdateWithoutSchoolsDataInput {
  academies?: Maybe<AcademyUpdateManyWithoutCreatedByInput>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
}

export interface ClanCreateInput {
  createdBy?: Maybe<UserCreateOneInput>;
  id?: Maybe<ID_Input>;
  name: String;
  players?: Maybe<PlayerCreateManyWithoutClanInput>;
  school: SchoolCreateOneWithoutClansInput;
}

export interface UserUpsertWithoutSchoolsInput {
  update: UserUpdateWithoutSchoolsDataInput;
  create: UserCreateWithoutSchoolsInput;
}

export interface AcademyCreateInput {
  country: String;
  createdBy?: Maybe<UserCreateOneWithoutAcademiesInput>;
  id?: Maybe<ID_Input>;
  name: String;
  schools?: Maybe<SchoolCreateManyWithoutAcademyInput>;
}

export interface PouleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  players_every?: Maybe<PlayerWhereInput>;
  players_some?: Maybe<PlayerWhereInput>;
  players_none?: Maybe<PlayerWhereInput>;
  tournament?: Maybe<TournamentWhereInput>;
  AND?: Maybe<PouleWhereInput[] | PouleWhereInput>;
  OR?: Maybe<PouleWhereInput[] | PouleWhereInput>;
  NOT?: Maybe<PouleWhereInput[] | PouleWhereInput>;
}

export interface UserCreateWithoutAcademiesInput {
  email: String;
  id?: Maybe<ID_Input>;
  name: String;
  password: String;
  schools?: Maybe<SchoolCreateManyWithoutCreatedByInput>;
}

export interface UserUpsertWithoutAcademiesInput {
  update: UserUpdateWithoutAcademiesDataInput;
  create: UserCreateWithoutAcademiesInput;
}

export interface SchoolCreateWithoutCreatedByInput {
  academy: AcademyCreateOneWithoutSchoolsInput;
  clans?: Maybe<ClanCreateManyWithoutSchoolInput>;
  id?: Maybe<ID_Input>;
  name: String;
}

export interface SchoolUpsertWithWhereUniqueWithoutCreatedByInput {
  where: SchoolWhereUniqueInput;
  update: SchoolUpdateWithoutCreatedByDataInput;
  create: SchoolCreateWithoutCreatedByInput;
}

export interface AcademyCreateWithoutSchoolsInput {
  country: String;
  createdBy?: Maybe<UserCreateOneWithoutAcademiesInput>;
  id?: Maybe<ID_Input>;
  name: String;
}

export interface ClanUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface ClanCreateWithoutSchoolInput {
  createdBy?: Maybe<UserCreateOneInput>;
  id?: Maybe<ID_Input>;
  name: String;
  players?: Maybe<PlayerCreateManyWithoutClanInput>;
}

export interface ClanUpdateManyWithWhereNestedInput {
  where: ClanScalarWhereInput;
  data: ClanUpdateManyDataInput;
}

export interface UserCreateInput {
  academies?: Maybe<AcademyCreateManyWithoutCreatedByInput>;
  email: String;
  id?: Maybe<ID_Input>;
  name: String;
  password: String;
  schools?: Maybe<SchoolCreateManyWithoutCreatedByInput>;
}

export interface ClanScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ClanScalarWhereInput[] | ClanScalarWhereInput>;
  OR?: Maybe<ClanScalarWhereInput[] | ClanScalarWhereInput>;
  NOT?: Maybe<ClanScalarWhereInput[] | ClanScalarWhereInput>;
}

export interface AcademyCreateWithoutCreatedByInput {
  country: String;
  id?: Maybe<ID_Input>;
  name: String;
  schools?: Maybe<SchoolCreateManyWithoutAcademyInput>;
}

export interface ClanUpsertWithWhereUniqueWithoutSchoolInput {
  where: ClanWhereUniqueInput;
  update: ClanUpdateWithoutSchoolDataInput;
  create: ClanCreateWithoutSchoolInput;
}

export interface SchoolCreateWithoutAcademyInput {
  clans?: Maybe<ClanCreateManyWithoutSchoolInput>;
  createdBy?: Maybe<UserCreateOneWithoutSchoolsInput>;
  id?: Maybe<ID_Input>;
  name: String;
}

export interface PlayerUpsertWithWhereUniqueWithoutClanInput {
  where: PlayerWhereUniqueInput;
  update: PlayerUpdateWithoutClanDataInput;
  create: PlayerCreateWithoutClanInput;
}

export interface UserCreateWithoutSchoolsInput {
  academies?: Maybe<AcademyCreateManyWithoutCreatedByInput>;
  email: String;
  id?: Maybe<ID_Input>;
  name: String;
  password: String;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface PlayerCreateWithoutClanInput {
  createdBy?: Maybe<UserCreateOneInput>;
  familyName: String;
  forms?: Maybe<FormCreateManyInput>;
  id?: Maybe<ID_Input>;
  name: String;
  nickname: String;
  poules?: Maybe<PouleCreateManyWithoutPlayersInput>;
  tournaments?: Maybe<TournamentCreateManyWithoutPlayersInput>;
}

export interface PlayerUpdateManyWithoutClanInput {
  create?: Maybe<PlayerCreateWithoutClanInput[] | PlayerCreateWithoutClanInput>;
  delete?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  connect?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  set?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  disconnect?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  update?: Maybe<
    | PlayerUpdateWithWhereUniqueWithoutClanInput[]
    | PlayerUpdateWithWhereUniqueWithoutClanInput
  >;
  upsert?: Maybe<
    | PlayerUpsertWithWhereUniqueWithoutClanInput[]
    | PlayerUpsertWithWhereUniqueWithoutClanInput
  >;
  deleteMany?: Maybe<PlayerScalarWhereInput[] | PlayerScalarWhereInput>;
  updateMany?: Maybe<
    | PlayerUpdateManyWithWhereNestedInput[]
    | PlayerUpdateManyWithWhereNestedInput
  >;
}

export interface FormCreateInput {
  createdBy?: Maybe<UserCreateOneInput>;
  id?: Maybe<ID_Input>;
  name: String;
}

export interface PlayerUpdateWithWhereUniqueWithoutClanInput {
  where: PlayerWhereUniqueInput;
  data: PlayerUpdateWithoutClanDataInput;
}

export interface PouleCreateWithoutPlayersInput {
  id?: Maybe<ID_Input>;
  name: String;
  tournament: TournamentCreateOneWithoutPoulesInput;
}

export interface PlayerUpdateWithoutClanDataInput {
  createdBy?: Maybe<UserUpdateOneInput>;
  familyName?: Maybe<String>;
  forms?: Maybe<FormUpdateManyInput>;
  name?: Maybe<String>;
  nickname?: Maybe<String>;
  poules?: Maybe<PouleUpdateManyWithoutPlayersInput>;
  tournaments?: Maybe<TournamentUpdateManyWithoutPlayersInput>;
}

export interface TournamentCreateWithoutPoulesInput {
  createdBy?: Maybe<UserCreateOneInput>;
  id?: Maybe<ID_Input>;
  name: String;
  players?: Maybe<PlayerCreateManyWithoutTournamentsInput>;
  poulesType: PoulesType;
}

export interface FormUpdateManyInput {
  create?: Maybe<FormCreateInput[] | FormCreateInput>;
  update?: Maybe<
    | FormUpdateWithWhereUniqueNestedInput[]
    | FormUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | FormUpsertWithWhereUniqueNestedInput[]
    | FormUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<FormWhereUniqueInput[] | FormWhereUniqueInput>;
  connect?: Maybe<FormWhereUniqueInput[] | FormWhereUniqueInput>;
  set?: Maybe<FormWhereUniqueInput[] | FormWhereUniqueInput>;
  disconnect?: Maybe<FormWhereUniqueInput[] | FormWhereUniqueInput>;
  deleteMany?: Maybe<FormScalarWhereInput[] | FormScalarWhereInput>;
  updateMany?: Maybe<
    FormUpdateManyWithWhereNestedInput[] | FormUpdateManyWithWhereNestedInput
  >;
}

export interface PlayerCreateWithoutTournamentsInput {
  clan: ClanCreateOneWithoutPlayersInput;
  createdBy?: Maybe<UserCreateOneInput>;
  familyName: String;
  forms?: Maybe<FormCreateManyInput>;
  id?: Maybe<ID_Input>;
  name: String;
  nickname: String;
  poules?: Maybe<PouleCreateManyWithoutPlayersInput>;
}

export interface FormUpdateWithWhereUniqueNestedInput {
  where: FormWhereUniqueInput;
  data: FormUpdateDataInput;
}

export interface ClanCreateWithoutPlayersInput {
  createdBy?: Maybe<UserCreateOneInput>;
  id?: Maybe<ID_Input>;
  name: String;
  school: SchoolCreateOneWithoutClansInput;
}

export interface FormUpdateDataInput {
  createdBy?: Maybe<UserUpdateOneInput>;
  name?: Maybe<String>;
}

export interface SchoolCreateWithoutClansInput {
  academy: AcademyCreateOneWithoutSchoolsInput;
  createdBy?: Maybe<UserCreateOneWithoutSchoolsInput>;
  id?: Maybe<ID_Input>;
  name: String;
}

export interface FormUpsertWithWhereUniqueNestedInput {
  where: FormWhereUniqueInput;
  update: FormUpdateDataInput;
  create: FormCreateInput;
}

export interface TournamentCreateWithoutPlayersInput {
  createdBy?: Maybe<UserCreateOneInput>;
  id?: Maybe<ID_Input>;
  name: String;
  poules?: Maybe<PouleCreateManyWithoutTournamentInput>;
  poulesType: PoulesType;
}

export interface FormScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<FormScalarWhereInput[] | FormScalarWhereInput>;
  OR?: Maybe<FormScalarWhereInput[] | FormScalarWhereInput>;
  NOT?: Maybe<FormScalarWhereInput[] | FormScalarWhereInput>;
}

export interface PouleCreateWithoutTournamentInput {
  id?: Maybe<ID_Input>;
  name: String;
  players?: Maybe<PlayerCreateManyWithoutPoulesInput>;
}

export interface FormUpdateManyWithWhereNestedInput {
  where: FormScalarWhereInput;
  data: FormUpdateManyDataInput;
}

export interface PlayerCreateWithoutPoulesInput {
  clan: ClanCreateOneWithoutPlayersInput;
  createdBy?: Maybe<UserCreateOneInput>;
  familyName: String;
  forms?: Maybe<FormCreateManyInput>;
  id?: Maybe<ID_Input>;
  name: String;
  nickname: String;
  tournaments?: Maybe<TournamentCreateManyWithoutPlayersInput>;
}

export interface FormUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface UserUpdateOneWithoutAcademiesInput {
  create?: Maybe<UserCreateWithoutAcademiesInput>;
  update?: Maybe<UserUpdateWithoutAcademiesDataInput>;
  upsert?: Maybe<UserUpsertWithoutAcademiesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface PouleUpdateManyWithoutPlayersInput {
  create?: Maybe<
    PouleCreateWithoutPlayersInput[] | PouleCreateWithoutPlayersInput
  >;
  delete?: Maybe<PouleWhereUniqueInput[] | PouleWhereUniqueInput>;
  connect?: Maybe<PouleWhereUniqueInput[] | PouleWhereUniqueInput>;
  set?: Maybe<PouleWhereUniqueInput[] | PouleWhereUniqueInput>;
  disconnect?: Maybe<PouleWhereUniqueInput[] | PouleWhereUniqueInput>;
  update?: Maybe<
    | PouleUpdateWithWhereUniqueWithoutPlayersInput[]
    | PouleUpdateWithWhereUniqueWithoutPlayersInput
  >;
  upsert?: Maybe<
    | PouleUpsertWithWhereUniqueWithoutPlayersInput[]
    | PouleUpsertWithWhereUniqueWithoutPlayersInput
  >;
  deleteMany?: Maybe<PouleScalarWhereInput[] | PouleScalarWhereInput>;
  updateMany?: Maybe<
    PouleUpdateManyWithWhereNestedInput[] | PouleUpdateManyWithWhereNestedInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface PouleUpdateWithWhereUniqueWithoutPlayersInput {
  where: PouleWhereUniqueInput;
  data: PouleUpdateWithoutPlayersDataInput;
}

export interface PlayerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlayerWhereInput>;
  AND?: Maybe<PlayerSubscriptionWhereInput[] | PlayerSubscriptionWhereInput>;
  OR?: Maybe<PlayerSubscriptionWhereInput[] | PlayerSubscriptionWhereInput>;
  NOT?: Maybe<PlayerSubscriptionWhereInput[] | PlayerSubscriptionWhereInput>;
}

export interface PouleUpdateWithoutPlayersDataInput {
  name?: Maybe<String>;
  tournament?: Maybe<TournamentUpdateOneRequiredWithoutPoulesInput>;
}

export interface AcademySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AcademyWhereInput>;
  AND?: Maybe<AcademySubscriptionWhereInput[] | AcademySubscriptionWhereInput>;
  OR?: Maybe<AcademySubscriptionWhereInput[] | AcademySubscriptionWhereInput>;
  NOT?: Maybe<AcademySubscriptionWhereInput[] | AcademySubscriptionWhereInput>;
}

export interface TournamentUpdateOneRequiredWithoutPoulesInput {
  create?: Maybe<TournamentCreateWithoutPoulesInput>;
  update?: Maybe<TournamentUpdateWithoutPoulesDataInput>;
  upsert?: Maybe<TournamentUpsertWithoutPoulesInput>;
  connect?: Maybe<TournamentWhereUniqueInput>;
}

export interface TournamentUpdateManyMutationInput {
  name?: Maybe<String>;
  poulesType?: Maybe<PoulesType>;
}

export interface TournamentUpdateWithoutPoulesDataInput {
  createdBy?: Maybe<UserUpdateOneInput>;
  name?: Maybe<String>;
  players?: Maybe<PlayerUpdateManyWithoutTournamentsInput>;
  poulesType?: Maybe<PoulesType>;
}

export interface SchoolUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface PlayerUpdateManyWithoutTournamentsInput {
  create?: Maybe<
    PlayerCreateWithoutTournamentsInput[] | PlayerCreateWithoutTournamentsInput
  >;
  delete?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  connect?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  set?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  disconnect?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  update?: Maybe<
    | PlayerUpdateWithWhereUniqueWithoutTournamentsInput[]
    | PlayerUpdateWithWhereUniqueWithoutTournamentsInput
  >;
  upsert?: Maybe<
    | PlayerUpsertWithWhereUniqueWithoutTournamentsInput[]
    | PlayerUpsertWithWhereUniqueWithoutTournamentsInput
  >;
  deleteMany?: Maybe<PlayerScalarWhereInput[] | PlayerScalarWhereInput>;
  updateMany?: Maybe<
    | PlayerUpdateManyWithWhereNestedInput[]
    | PlayerUpdateManyWithWhereNestedInput
  >;
}

export interface PouleUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface PlayerUpdateWithWhereUniqueWithoutTournamentsInput {
  where: PlayerWhereUniqueInput;
  data: PlayerUpdateWithoutTournamentsDataInput;
}

export interface PlayerUpdateManyMutationInput {
  familyName?: Maybe<String>;
  name?: Maybe<String>;
  nickname?: Maybe<String>;
}

export interface PlayerUpdateWithoutTournamentsDataInput {
  clan?: Maybe<ClanUpdateOneRequiredWithoutPlayersInput>;
  createdBy?: Maybe<UserUpdateOneInput>;
  familyName?: Maybe<String>;
  forms?: Maybe<FormUpdateManyInput>;
  name?: Maybe<String>;
  nickname?: Maybe<String>;
  poules?: Maybe<PouleUpdateManyWithoutPlayersInput>;
}

export interface FormUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ClanUpdateOneRequiredWithoutPlayersInput {
  create?: Maybe<ClanCreateWithoutPlayersInput>;
  update?: Maybe<ClanUpdateWithoutPlayersDataInput>;
  upsert?: Maybe<ClanUpsertWithoutPlayersInput>;
  connect?: Maybe<ClanWhereUniqueInput>;
}

export interface ClanUpdateInput {
  createdBy?: Maybe<UserUpdateOneInput>;
  name?: Maybe<String>;
  players?: Maybe<PlayerUpdateManyWithoutClanInput>;
  school?: Maybe<SchoolUpdateOneRequiredWithoutClansInput>;
}

export interface ClanUpdateWithoutPlayersDataInput {
  createdBy?: Maybe<UserUpdateOneInput>;
  name?: Maybe<String>;
  school?: Maybe<SchoolUpdateOneRequiredWithoutClansInput>;
}

export interface UserCreateOneWithoutAcademiesInput {
  create?: Maybe<UserCreateWithoutAcademiesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface SchoolUpdateOneRequiredWithoutClansInput {
  create?: Maybe<SchoolCreateWithoutClansInput>;
  update?: Maybe<SchoolUpdateWithoutClansDataInput>;
  upsert?: Maybe<SchoolUpsertWithoutClansInput>;
  connect?: Maybe<SchoolWhereUniqueInput>;
}

export interface AcademyCreateOneWithoutSchoolsInput {
  create?: Maybe<AcademyCreateWithoutSchoolsInput>;
  connect?: Maybe<AcademyWhereUniqueInput>;
}

export interface SchoolUpdateWithoutClansDataInput {
  academy?: Maybe<AcademyUpdateOneRequiredWithoutSchoolsInput>;
  createdBy?: Maybe<UserUpdateOneWithoutSchoolsInput>;
  name?: Maybe<String>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface SchoolUpsertWithoutClansInput {
  update: SchoolUpdateWithoutClansDataInput;
  create: SchoolCreateWithoutClansInput;
}

export interface SchoolCreateManyWithoutAcademyInput {
  create?: Maybe<
    SchoolCreateWithoutAcademyInput[] | SchoolCreateWithoutAcademyInput
  >;
  connect?: Maybe<SchoolWhereUniqueInput[] | SchoolWhereUniqueInput>;
}

export interface ClanUpsertWithoutPlayersInput {
  update: ClanUpdateWithoutPlayersDataInput;
  create: ClanCreateWithoutPlayersInput;
}

export interface PlayerCreateManyWithoutClanInput {
  create?: Maybe<PlayerCreateWithoutClanInput[] | PlayerCreateWithoutClanInput>;
  connect?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
}

export interface PlayerUpsertWithWhereUniqueWithoutTournamentsInput {
  where: PlayerWhereUniqueInput;
  update: PlayerUpdateWithoutTournamentsDataInput;
  create: PlayerCreateWithoutTournamentsInput;
}

export interface PouleCreateManyWithoutPlayersInput {
  create?: Maybe<
    PouleCreateWithoutPlayersInput[] | PouleCreateWithoutPlayersInput
  >;
  connect?: Maybe<PouleWhereUniqueInput[] | PouleWhereUniqueInput>;
}

export interface PlayerScalarWhereInput {
  familyName?: Maybe<String>;
  familyName_not?: Maybe<String>;
  familyName_in?: Maybe<String[] | String>;
  familyName_not_in?: Maybe<String[] | String>;
  familyName_lt?: Maybe<String>;
  familyName_lte?: Maybe<String>;
  familyName_gt?: Maybe<String>;
  familyName_gte?: Maybe<String>;
  familyName_contains?: Maybe<String>;
  familyName_not_contains?: Maybe<String>;
  familyName_starts_with?: Maybe<String>;
  familyName_not_starts_with?: Maybe<String>;
  familyName_ends_with?: Maybe<String>;
  familyName_not_ends_with?: Maybe<String>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  nickname?: Maybe<String>;
  nickname_not?: Maybe<String>;
  nickname_in?: Maybe<String[] | String>;
  nickname_not_in?: Maybe<String[] | String>;
  nickname_lt?: Maybe<String>;
  nickname_lte?: Maybe<String>;
  nickname_gt?: Maybe<String>;
  nickname_gte?: Maybe<String>;
  nickname_contains?: Maybe<String>;
  nickname_not_contains?: Maybe<String>;
  nickname_starts_with?: Maybe<String>;
  nickname_not_starts_with?: Maybe<String>;
  nickname_ends_with?: Maybe<String>;
  nickname_not_ends_with?: Maybe<String>;
  AND?: Maybe<PlayerScalarWhereInput[] | PlayerScalarWhereInput>;
  OR?: Maybe<PlayerScalarWhereInput[] | PlayerScalarWhereInput>;
  NOT?: Maybe<PlayerScalarWhereInput[] | PlayerScalarWhereInput>;
}

export interface PlayerCreateManyWithoutTournamentsInput {
  create?: Maybe<
    PlayerCreateWithoutTournamentsInput[] | PlayerCreateWithoutTournamentsInput
  >;
  connect?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
}

export interface PlayerUpdateManyWithWhereNestedInput {
  where: PlayerScalarWhereInput;
  data: PlayerUpdateManyDataInput;
}

export interface SchoolCreateOneWithoutClansInput {
  create?: Maybe<SchoolCreateWithoutClansInput>;
  connect?: Maybe<SchoolWhereUniqueInput>;
}

export interface PlayerUpdateManyDataInput {
  familyName?: Maybe<String>;
  name?: Maybe<String>;
  nickname?: Maybe<String>;
}

export interface PouleCreateManyWithoutTournamentInput {
  create?: Maybe<
    PouleCreateWithoutTournamentInput[] | PouleCreateWithoutTournamentInput
  >;
  connect?: Maybe<PouleWhereUniqueInput[] | PouleWhereUniqueInput>;
}

export interface TournamentUpsertWithoutPoulesInput {
  update: TournamentUpdateWithoutPoulesDataInput;
  create: TournamentCreateWithoutPoulesInput;
}

export interface AcademyUpdateInput {
  country?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneWithoutAcademiesInput>;
  name?: Maybe<String>;
  schools?: Maybe<SchoolUpdateManyWithoutAcademyInput>;
}

export interface PouleUpsertWithWhereUniqueWithoutPlayersInput {
  where: PouleWhereUniqueInput;
  update: PouleUpdateWithoutPlayersDataInput;
  create: PouleCreateWithoutPlayersInput;
}

export interface SchoolSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SchoolWhereInput>;
  AND?: Maybe<SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput>;
  OR?: Maybe<SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput>;
  NOT?: Maybe<SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput>;
}

export interface PouleScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<PouleScalarWhereInput[] | PouleScalarWhereInput>;
  OR?: Maybe<PouleScalarWhereInput[] | PouleScalarWhereInput>;
  NOT?: Maybe<PouleScalarWhereInput[] | PouleScalarWhereInput>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
}

export interface PouleUpdateManyWithWhereNestedInput {
  where: PouleScalarWhereInput;
  data: PouleUpdateManyDataInput;
}

export interface SchoolUpdateInput {
  academy?: Maybe<AcademyUpdateOneRequiredWithoutSchoolsInput>;
  clans?: Maybe<ClanUpdateManyWithoutSchoolInput>;
  createdBy?: Maybe<UserUpdateOneWithoutSchoolsInput>;
  name?: Maybe<String>;
}

export interface PouleUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface PlayerUpdateInput {
  clan?: Maybe<ClanUpdateOneRequiredWithoutPlayersInput>;
  createdBy?: Maybe<UserUpdateOneInput>;
  familyName?: Maybe<String>;
  forms?: Maybe<FormUpdateManyInput>;
  name?: Maybe<String>;
  nickname?: Maybe<String>;
  poules?: Maybe<PouleUpdateManyWithoutPlayersInput>;
  tournaments?: Maybe<TournamentUpdateManyWithoutPlayersInput>;
}

export interface TournamentUpdateManyWithoutPlayersInput {
  create?: Maybe<
    TournamentCreateWithoutPlayersInput[] | TournamentCreateWithoutPlayersInput
  >;
  delete?: Maybe<TournamentWhereUniqueInput[] | TournamentWhereUniqueInput>;
  connect?: Maybe<TournamentWhereUniqueInput[] | TournamentWhereUniqueInput>;
  set?: Maybe<TournamentWhereUniqueInput[] | TournamentWhereUniqueInput>;
  disconnect?: Maybe<TournamentWhereUniqueInput[] | TournamentWhereUniqueInput>;
  update?: Maybe<
    | TournamentUpdateWithWhereUniqueWithoutPlayersInput[]
    | TournamentUpdateWithWhereUniqueWithoutPlayersInput
  >;
  upsert?: Maybe<
    | TournamentUpsertWithWhereUniqueWithoutPlayersInput[]
    | TournamentUpsertWithWhereUniqueWithoutPlayersInput
  >;
  deleteMany?: Maybe<TournamentScalarWhereInput[] | TournamentScalarWhereInput>;
  updateMany?: Maybe<
    | TournamentUpdateManyWithWhereNestedInput[]
    | TournamentUpdateManyWithWhereNestedInput
  >;
}

export interface ClanCreateManyWithoutSchoolInput {
  create?: Maybe<ClanCreateWithoutSchoolInput[] | ClanCreateWithoutSchoolInput>;
  connect?: Maybe<ClanWhereUniqueInput[] | ClanWhereUniqueInput>;
}

export interface TournamentUpdateWithWhereUniqueWithoutPlayersInput {
  where: TournamentWhereUniqueInput;
  data: TournamentUpdateWithoutPlayersDataInput;
}

export interface UserCreateOneWithoutSchoolsInput {
  create?: Maybe<UserCreateWithoutSchoolsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface TournamentUpdateWithoutPlayersDataInput {
  createdBy?: Maybe<UserUpdateOneInput>;
  name?: Maybe<String>;
  poules?: Maybe<PouleUpdateManyWithoutTournamentInput>;
  poulesType?: Maybe<PoulesType>;
}

export interface TournamentCreateOneWithoutPoulesInput {
  create?: Maybe<TournamentCreateWithoutPoulesInput>;
  connect?: Maybe<TournamentWhereUniqueInput>;
}

export interface PouleUpdateManyWithoutTournamentInput {
  create?: Maybe<
    PouleCreateWithoutTournamentInput[] | PouleCreateWithoutTournamentInput
  >;
  delete?: Maybe<PouleWhereUniqueInput[] | PouleWhereUniqueInput>;
  connect?: Maybe<PouleWhereUniqueInput[] | PouleWhereUniqueInput>;
  set?: Maybe<PouleWhereUniqueInput[] | PouleWhereUniqueInput>;
  disconnect?: Maybe<PouleWhereUniqueInput[] | PouleWhereUniqueInput>;
  update?: Maybe<
    | PouleUpdateWithWhereUniqueWithoutTournamentInput[]
    | PouleUpdateWithWhereUniqueWithoutTournamentInput
  >;
  upsert?: Maybe<
    | PouleUpsertWithWhereUniqueWithoutTournamentInput[]
    | PouleUpsertWithWhereUniqueWithoutTournamentInput
  >;
  deleteMany?: Maybe<PouleScalarWhereInput[] | PouleScalarWhereInput>;
  updateMany?: Maybe<
    PouleUpdateManyWithWhereNestedInput[] | PouleUpdateManyWithWhereNestedInput
  >;
}

export interface TournamentCreateManyWithoutPlayersInput {
  create?: Maybe<
    TournamentCreateWithoutPlayersInput[] | TournamentCreateWithoutPlayersInput
  >;
  connect?: Maybe<TournamentWhereUniqueInput[] | TournamentWhereUniqueInput>;
}

export interface PouleUpdateWithWhereUniqueWithoutTournamentInput {
  where: PouleWhereUniqueInput;
  data: PouleUpdateWithoutTournamentDataInput;
}

export interface UserUpdateWithoutAcademiesDataInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  schools?: Maybe<SchoolUpdateManyWithoutCreatedByInput>;
}

export interface PouleUpdateWithoutTournamentDataInput {
  name?: Maybe<String>;
  players?: Maybe<PlayerUpdateManyWithoutPoulesInput>;
}

export interface TournamentUpdateInput {
  createdBy?: Maybe<UserUpdateOneInput>;
  name?: Maybe<String>;
  players?: Maybe<PlayerUpdateManyWithoutTournamentsInput>;
  poules?: Maybe<PouleUpdateManyWithoutTournamentInput>;
  poulesType?: Maybe<PoulesType>;
}

export interface PlayerUpdateManyWithoutPoulesInput {
  create?: Maybe<
    PlayerCreateWithoutPoulesInput[] | PlayerCreateWithoutPoulesInput
  >;
  delete?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  connect?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  set?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  disconnect?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
  update?: Maybe<
    | PlayerUpdateWithWhereUniqueWithoutPoulesInput[]
    | PlayerUpdateWithWhereUniqueWithoutPoulesInput
  >;
  upsert?: Maybe<
    | PlayerUpsertWithWhereUniqueWithoutPoulesInput[]
    | PlayerUpsertWithWhereUniqueWithoutPoulesInput
  >;
  deleteMany?: Maybe<PlayerScalarWhereInput[] | PlayerScalarWhereInput>;
  updateMany?: Maybe<
    | PlayerUpdateManyWithWhereNestedInput[]
    | PlayerUpdateManyWithWhereNestedInput
  >;
}

export interface FormUpdateInput {
  createdBy?: Maybe<UserUpdateOneInput>;
  name?: Maybe<String>;
}

export interface PlayerUpdateWithWhereUniqueWithoutPoulesInput {
  where: PlayerWhereUniqueInput;
  data: PlayerUpdateWithoutPoulesDataInput;
}

export interface AcademyCreateManyWithoutCreatedByInput {
  create?: Maybe<
    AcademyCreateWithoutCreatedByInput[] | AcademyCreateWithoutCreatedByInput
  >;
  connect?: Maybe<AcademyWhereUniqueInput[] | AcademyWhereUniqueInput>;
}

export interface PlayerUpdateWithoutPoulesDataInput {
  clan?: Maybe<ClanUpdateOneRequiredWithoutPlayersInput>;
  createdBy?: Maybe<UserUpdateOneInput>;
  familyName?: Maybe<String>;
  forms?: Maybe<FormUpdateManyInput>;
  name?: Maybe<String>;
  nickname?: Maybe<String>;
  tournaments?: Maybe<TournamentUpdateManyWithoutPlayersInput>;
}

export interface ClanCreateOneWithoutPlayersInput {
  create?: Maybe<ClanCreateWithoutPlayersInput>;
  connect?: Maybe<ClanWhereUniqueInput>;
}

export interface PlayerUpsertWithWhereUniqueWithoutPoulesInput {
  where: PlayerWhereUniqueInput;
  update: PlayerUpdateWithoutPoulesDataInput;
  create: PlayerCreateWithoutPoulesInput;
}

export interface FormSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FormWhereInput>;
  AND?: Maybe<FormSubscriptionWhereInput[] | FormSubscriptionWhereInput>;
  OR?: Maybe<FormSubscriptionWhereInput[] | FormSubscriptionWhereInput>;
  NOT?: Maybe<FormSubscriptionWhereInput[] | FormSubscriptionWhereInput>;
}

export interface TournamentUpdateManyWithWhereNestedInput {
  where: TournamentScalarWhereInput;
  data: TournamentUpdateManyDataInput;
}

export interface TournamentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  poulesType?: Maybe<PoulesType>;
  poulesType_not?: Maybe<PoulesType>;
  poulesType_in?: Maybe<PoulesType[] | PoulesType>;
  poulesType_not_in?: Maybe<PoulesType[] | PoulesType>;
  AND?: Maybe<TournamentScalarWhereInput[] | TournamentScalarWhereInput>;
  OR?: Maybe<TournamentScalarWhereInput[] | TournamentScalarWhereInput>;
  NOT?: Maybe<TournamentScalarWhereInput[] | TournamentScalarWhereInput>;
}

export interface TournamentUpsertWithWhereUniqueWithoutPlayersInput {
  where: TournamentWhereUniqueInput;
  update: TournamentUpdateWithoutPlayersDataInput;
  create: TournamentCreateWithoutPlayersInput;
}

export interface PouleUpsertWithWhereUniqueWithoutTournamentInput {
  where: PouleWhereUniqueInput;
  update: PouleUpdateWithoutTournamentDataInput;
  create: PouleCreateWithoutTournamentInput;
}

export interface PouleUpdateInput {
  name?: Maybe<String>;
  players?: Maybe<PlayerUpdateManyWithoutPoulesInput>;
  tournament?: Maybe<TournamentUpdateOneRequiredWithoutPoulesInput>;
}

export interface PlayerCreateManyWithoutPoulesInput {
  create?: Maybe<
    PlayerCreateWithoutPoulesInput[] | PlayerCreateWithoutPoulesInput
  >;
  connect?: Maybe<PlayerWhereUniqueInput[] | PlayerWhereUniqueInput>;
}

export interface FormCreateManyInput {
  create?: Maybe<FormCreateInput[] | FormCreateInput>;
  connect?: Maybe<FormWhereUniqueInput[] | FormWhereUniqueInput>;
}

export interface SchoolCreateManyWithoutCreatedByInput {
  create?: Maybe<
    SchoolCreateWithoutCreatedByInput[] | SchoolCreateWithoutCreatedByInput
  >;
  connect?: Maybe<SchoolWhereUniqueInput[] | SchoolWhereUniqueInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  email: String;
  id: ID_Output;
  name: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  email: () => Promise<String>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  email: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface FormEdge {
  node: Form;
  cursor: String;
}

export interface FormEdgePromise extends Promise<FormEdge>, Fragmentable {
  node: <T = FormPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FormEdgeSubscription
  extends Promise<AsyncIterator<FormEdge>>,
    Fragmentable {
  node: <T = FormSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Tournament {
  id: ID_Output;
  name: String;
  poulesType: PoulesType;
}

export interface TournamentPromise extends Promise<Tournament>, Fragmentable {
  createdBy: <T = UserPromise>() => T;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  players: <T = FragmentableArray<Player>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  poules: <T = FragmentableArray<Poule>>(args?: {
    where?: PouleWhereInput;
    orderBy?: PouleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  poulesType: () => Promise<PoulesType>;
}

export interface TournamentSubscription
  extends Promise<AsyncIterator<Tournament>>,
    Fragmentable {
  createdBy: <T = UserSubscription>() => T;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  players: <T = Promise<AsyncIterator<PlayerSubscription>>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  poules: <T = Promise<AsyncIterator<PouleSubscription>>>(args?: {
    where?: PouleWhereInput;
    orderBy?: PouleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  poulesType: () => Promise<AsyncIterator<PoulesType>>;
}

export interface TournamentNullablePromise
  extends Promise<Tournament | null>,
    Fragmentable {
  createdBy: <T = UserPromise>() => T;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  players: <T = FragmentableArray<Player>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  poules: <T = FragmentableArray<Poule>>(args?: {
    where?: PouleWhereInput;
    orderBy?: PouleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  poulesType: () => Promise<PoulesType>;
}

export interface FormConnection {
  pageInfo: PageInfo;
  edges: FormEdge[];
}

export interface FormConnectionPromise
  extends Promise<FormConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FormEdge>>() => T;
  aggregate: <T = AggregateFormPromise>() => T;
}

export interface FormConnectionSubscription
  extends Promise<AsyncIterator<FormConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FormEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFormSubscription>() => T;
}

export interface User {
  email: String;
  id: ID_Output;
  name: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  academies: <T = FragmentableArray<Academy>>(args?: {
    where?: AcademyWhereInput;
    orderBy?: AcademyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<String>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  schools: <T = FragmentableArray<School>>(args?: {
    where?: SchoolWhereInput;
    orderBy?: SchoolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  academies: <T = Promise<AsyncIterator<AcademySubscription>>>(args?: {
    where?: AcademyWhereInput;
    orderBy?: AcademyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  schools: <T = Promise<AsyncIterator<SchoolSubscription>>>(args?: {
    where?: SchoolWhereInput;
    orderBy?: SchoolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  academies: <T = FragmentableArray<Academy>>(args?: {
    where?: AcademyWhereInput;
    orderBy?: AcademyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<String>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  schools: <T = FragmentableArray<School>>(args?: {
    where?: SchoolWhereInput;
    orderBy?: SchoolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateClan {
  count: Int;
}

export interface AggregateClanPromise
  extends Promise<AggregateClan>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClanSubscription
  extends Promise<AsyncIterator<AggregateClan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Form {
  id: ID_Output;
  name: String;
}

export interface FormPromise extends Promise<Form>, Fragmentable {
  createdBy: <T = UserPromise>() => T;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface FormSubscription
  extends Promise<AsyncIterator<Form>>,
    Fragmentable {
  createdBy: <T = UserSubscription>() => T;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface FormNullablePromise
  extends Promise<Form | null>,
    Fragmentable {
  createdBy: <T = UserPromise>() => T;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface Player {
  familyName: String;
  id: ID_Output;
  name: String;
  nickname: String;
}

export interface PlayerPromise extends Promise<Player>, Fragmentable {
  clan: <T = ClanPromise>() => T;
  createdBy: <T = UserPromise>() => T;
  familyName: () => Promise<String>;
  forms: <T = FragmentableArray<Form>>(args?: {
    where?: FormWhereInput;
    orderBy?: FormOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  nickname: () => Promise<String>;
  poules: <T = FragmentableArray<Poule>>(args?: {
    where?: PouleWhereInput;
    orderBy?: PouleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tournaments: <T = FragmentableArray<Tournament>>(args?: {
    where?: TournamentWhereInput;
    orderBy?: TournamentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PlayerSubscription
  extends Promise<AsyncIterator<Player>>,
    Fragmentable {
  clan: <T = ClanSubscription>() => T;
  createdBy: <T = UserSubscription>() => T;
  familyName: () => Promise<AsyncIterator<String>>;
  forms: <T = Promise<AsyncIterator<FormSubscription>>>(args?: {
    where?: FormWhereInput;
    orderBy?: FormOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
  poules: <T = Promise<AsyncIterator<PouleSubscription>>>(args?: {
    where?: PouleWhereInput;
    orderBy?: PouleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tournaments: <T = Promise<AsyncIterator<TournamentSubscription>>>(args?: {
    where?: TournamentWhereInput;
    orderBy?: TournamentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PlayerNullablePromise
  extends Promise<Player | null>,
    Fragmentable {
  clan: <T = ClanPromise>() => T;
  createdBy: <T = UserPromise>() => T;
  familyName: () => Promise<String>;
  forms: <T = FragmentableArray<Form>>(args?: {
    where?: FormWhereInput;
    orderBy?: FormOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  nickname: () => Promise<String>;
  poules: <T = FragmentableArray<Poule>>(args?: {
    where?: PouleWhereInput;
    orderBy?: PouleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tournaments: <T = FragmentableArray<Tournament>>(args?: {
    where?: TournamentWhereInput;
    orderBy?: TournamentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TournamentSubscriptionPayload {
  mutation: MutationType;
  node: Tournament;
  updatedFields: String[];
  previousValues: TournamentPreviousValues;
}

export interface TournamentSubscriptionPayloadPromise
  extends Promise<TournamentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TournamentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TournamentPreviousValuesPromise>() => T;
}

export interface TournamentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TournamentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TournamentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TournamentPreviousValuesSubscription>() => T;
}

export interface School {
  id: ID_Output;
  name: String;
}

export interface SchoolPromise extends Promise<School>, Fragmentable {
  academy: <T = AcademyPromise>() => T;
  clans: <T = FragmentableArray<Clan>>(args?: {
    where?: ClanWhereInput;
    orderBy?: ClanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdBy: <T = UserPromise>() => T;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SchoolSubscription
  extends Promise<AsyncIterator<School>>,
    Fragmentable {
  academy: <T = AcademySubscription>() => T;
  clans: <T = Promise<AsyncIterator<ClanSubscription>>>(args?: {
    where?: ClanWhereInput;
    orderBy?: ClanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdBy: <T = UserSubscription>() => T;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SchoolNullablePromise
  extends Promise<School | null>,
    Fragmentable {
  academy: <T = AcademyPromise>() => T;
  clans: <T = FragmentableArray<Clan>>(args?: {
    where?: ClanWhereInput;
    orderBy?: ClanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdBy: <T = UserPromise>() => T;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface Clan {
  id: ID_Output;
  name: String;
}

export interface ClanPromise extends Promise<Clan>, Fragmentable {
  createdBy: <T = UserPromise>() => T;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  players: <T = FragmentableArray<Player>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  school: <T = SchoolPromise>() => T;
}

export interface ClanSubscription
  extends Promise<AsyncIterator<Clan>>,
    Fragmentable {
  createdBy: <T = UserSubscription>() => T;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  players: <T = Promise<AsyncIterator<PlayerSubscription>>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  school: <T = SchoolSubscription>() => T;
}

export interface ClanNullablePromise
  extends Promise<Clan | null>,
    Fragmentable {
  createdBy: <T = UserPromise>() => T;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  players: <T = FragmentableArray<Player>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  school: <T = SchoolPromise>() => T;
}

export interface AcademyConnection {
  pageInfo: PageInfo;
  edges: AcademyEdge[];
}

export interface AcademyConnectionPromise
  extends Promise<AcademyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AcademyEdge>>() => T;
  aggregate: <T = AggregateAcademyPromise>() => T;
}

export interface AcademyConnectionSubscription
  extends Promise<AsyncIterator<AcademyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AcademyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAcademySubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AcademySubscriptionPayload {
  mutation: MutationType;
  node: Academy;
  updatedFields: String[];
  previousValues: AcademyPreviousValues;
}

export interface AcademySubscriptionPayloadPromise
  extends Promise<AcademySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AcademyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AcademyPreviousValuesPromise>() => T;
}

export interface AcademySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AcademySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AcademySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AcademyPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AcademyPreviousValues {
  country: String;
  id: ID_Output;
  name: String;
}

export interface AcademyPreviousValuesPromise
  extends Promise<AcademyPreviousValues>,
    Fragmentable {
  country: () => Promise<String>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface AcademyPreviousValuesSubscription
  extends Promise<AsyncIterator<AcademyPreviousValues>>,
    Fragmentable {
  country: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface Academy {
  country: String;
  id: ID_Output;
  name: String;
}

export interface AcademyPromise extends Promise<Academy>, Fragmentable {
  country: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  schools: <T = FragmentableArray<School>>(args?: {
    where?: SchoolWhereInput;
    orderBy?: SchoolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AcademySubscription
  extends Promise<AsyncIterator<Academy>>,
    Fragmentable {
  country: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  schools: <T = Promise<AsyncIterator<SchoolSubscription>>>(args?: {
    where?: SchoolWhereInput;
    orderBy?: SchoolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AcademyNullablePromise
  extends Promise<Academy | null>,
    Fragmentable {
  country: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  schools: <T = FragmentableArray<School>>(args?: {
    where?: SchoolWhereInput;
    orderBy?: SchoolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ClanEdge {
  node: Clan;
  cursor: String;
}

export interface ClanEdgePromise extends Promise<ClanEdge>, Fragmentable {
  node: <T = ClanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClanEdgeSubscription
  extends Promise<AsyncIterator<ClanEdge>>,
    Fragmentable {
  node: <T = ClanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TournamentEdge {
  node: Tournament;
  cursor: String;
}

export interface TournamentEdgePromise
  extends Promise<TournamentEdge>,
    Fragmentable {
  node: <T = TournamentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TournamentEdgeSubscription
  extends Promise<AsyncIterator<TournamentEdge>>,
    Fragmentable {
  node: <T = TournamentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ClanSubscriptionPayload {
  mutation: MutationType;
  node: Clan;
  updatedFields: String[];
  previousValues: ClanPreviousValues;
}

export interface ClanSubscriptionPayloadPromise
  extends Promise<ClanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClanPreviousValuesPromise>() => T;
}

export interface ClanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClanPreviousValuesSubscription>() => T;
}

export interface AggregateSchool {
  count: Int;
}

export interface AggregateSchoolPromise
  extends Promise<AggregateSchool>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSchoolSubscription
  extends Promise<AsyncIterator<AggregateSchool>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClanPreviousValues {
  id: ID_Output;
  name: String;
}

export interface ClanPreviousValuesPromise
  extends Promise<ClanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ClanPreviousValuesSubscription
  extends Promise<AsyncIterator<ClanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SchoolConnection {
  pageInfo: PageInfo;
  edges: SchoolEdge[];
}

export interface SchoolConnectionPromise
  extends Promise<SchoolConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SchoolEdge>>() => T;
  aggregate: <T = AggregateSchoolPromise>() => T;
}

export interface SchoolConnectionSubscription
  extends Promise<AsyncIterator<SchoolConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SchoolEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSchoolSubscription>() => T;
}

export interface ClanConnection {
  pageInfo: PageInfo;
  edges: ClanEdge[];
}

export interface ClanConnectionPromise
  extends Promise<ClanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClanEdge>>() => T;
  aggregate: <T = AggregateClanPromise>() => T;
}

export interface ClanConnectionSubscription
  extends Promise<AsyncIterator<ClanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClanEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClanSubscription>() => T;
}

export interface PouleEdge {
  node: Poule;
  cursor: String;
}

export interface PouleEdgePromise extends Promise<PouleEdge>, Fragmentable {
  node: <T = PoulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PouleEdgeSubscription
  extends Promise<AsyncIterator<PouleEdge>>,
    Fragmentable {
  node: <T = PouleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FormSubscriptionPayload {
  mutation: MutationType;
  node: Form;
  updatedFields: String[];
  previousValues: FormPreviousValues;
}

export interface FormSubscriptionPayloadPromise
  extends Promise<FormSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FormPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FormPreviousValuesPromise>() => T;
}

export interface FormSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FormSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FormSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FormPreviousValuesSubscription>() => T;
}

export interface AggregatePlayer {
  count: Int;
}

export interface AggregatePlayerPromise
  extends Promise<AggregatePlayer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlayerSubscription
  extends Promise<AsyncIterator<AggregatePlayer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FormPreviousValues {
  id: ID_Output;
  name: String;
}

export interface FormPreviousValuesPromise
  extends Promise<FormPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface FormPreviousValuesSubscription
  extends Promise<AsyncIterator<FormPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface PlayerConnection {
  pageInfo: PageInfo;
  edges: PlayerEdge[];
}

export interface PlayerConnectionPromise
  extends Promise<PlayerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlayerEdge>>() => T;
  aggregate: <T = AggregatePlayerPromise>() => T;
}

export interface PlayerConnectionSubscription
  extends Promise<AsyncIterator<PlayerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlayerEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlayerSubscription>() => T;
}

export interface AggregateAcademy {
  count: Int;
}

export interface AggregateAcademyPromise
  extends Promise<AggregateAcademy>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAcademySubscription
  extends Promise<AsyncIterator<AggregateAcademy>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Poule {
  id: ID_Output;
  name: String;
}

export interface PoulePromise extends Promise<Poule>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  players: <T = FragmentableArray<Player>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tournament: <T = TournamentPromise>() => T;
}

export interface PouleSubscription
  extends Promise<AsyncIterator<Poule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  players: <T = Promise<AsyncIterator<PlayerSubscription>>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tournament: <T = TournamentSubscription>() => T;
}

export interface PouleNullablePromise
  extends Promise<Poule | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  players: <T = FragmentableArray<Player>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tournament: <T = TournamentPromise>() => T;
}

export interface PlayerSubscriptionPayload {
  mutation: MutationType;
  node: Player;
  updatedFields: String[];
  previousValues: PlayerPreviousValues;
}

export interface PlayerSubscriptionPayloadPromise
  extends Promise<PlayerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlayerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlayerPreviousValuesPromise>() => T;
}

export interface PlayerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlayerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlayerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlayerPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlayerPreviousValues {
  familyName: String;
  id: ID_Output;
  name: String;
  nickname: String;
}

export interface PlayerPreviousValuesPromise
  extends Promise<PlayerPreviousValues>,
    Fragmentable {
  familyName: () => Promise<String>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  nickname: () => Promise<String>;
}

export interface PlayerPreviousValuesSubscription
  extends Promise<AsyncIterator<PlayerPreviousValues>>,
    Fragmentable {
  familyName: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTournament {
  count: Int;
}

export interface AggregateTournamentPromise
  extends Promise<AggregateTournament>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTournamentSubscription
  extends Promise<AsyncIterator<AggregateTournament>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AcademyEdge {
  node: Academy;
  cursor: String;
}

export interface AcademyEdgePromise extends Promise<AcademyEdge>, Fragmentable {
  node: <T = AcademyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AcademyEdgeSubscription
  extends Promise<AsyncIterator<AcademyEdge>>,
    Fragmentable {
  node: <T = AcademySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SchoolEdge {
  node: School;
  cursor: String;
}

export interface SchoolEdgePromise extends Promise<SchoolEdge>, Fragmentable {
  node: <T = SchoolPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SchoolEdgeSubscription
  extends Promise<AsyncIterator<SchoolEdge>>,
    Fragmentable {
  node: <T = SchoolSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PouleSubscriptionPayload {
  mutation: MutationType;
  node: Poule;
  updatedFields: String[];
  previousValues: PoulePreviousValues;
}

export interface PouleSubscriptionPayloadPromise
  extends Promise<PouleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PoulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PoulePreviousValuesPromise>() => T;
}

export interface PouleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PouleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PouleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PoulePreviousValuesSubscription>() => T;
}

export interface PouleConnection {
  pageInfo: PageInfo;
  edges: PouleEdge[];
}

export interface PouleConnectionPromise
  extends Promise<PouleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PouleEdge>>() => T;
  aggregate: <T = AggregatePoulePromise>() => T;
}

export interface PouleConnectionSubscription
  extends Promise<AsyncIterator<PouleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PouleEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePouleSubscription>() => T;
}

export interface PoulePreviousValues {
  id: ID_Output;
  name: String;
}

export interface PoulePreviousValuesPromise
  extends Promise<PoulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface PoulePreviousValuesSubscription
  extends Promise<AsyncIterator<PoulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateForm {
  count: Int;
}

export interface AggregateFormPromise
  extends Promise<AggregateForm>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFormSubscription
  extends Promise<AsyncIterator<AggregateForm>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface SchoolPreviousValues {
  id: ID_Output;
  name: String;
}

export interface SchoolPreviousValuesPromise
  extends Promise<SchoolPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SchoolPreviousValuesSubscription
  extends Promise<AsyncIterator<SchoolPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SchoolSubscriptionPayload {
  mutation: MutationType;
  node: School;
  updatedFields: String[];
  previousValues: SchoolPreviousValues;
}

export interface SchoolSubscriptionPayloadPromise
  extends Promise<SchoolSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchoolPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchoolPreviousValuesPromise>() => T;
}

export interface SchoolSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SchoolSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SchoolSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchoolPreviousValuesSubscription>() => T;
}

export interface TournamentPreviousValues {
  id: ID_Output;
  name: String;
  poulesType: PoulesType;
}

export interface TournamentPreviousValuesPromise
  extends Promise<TournamentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  poulesType: () => Promise<PoulesType>;
}

export interface TournamentPreviousValuesSubscription
  extends Promise<AsyncIterator<TournamentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  poulesType: () => Promise<AsyncIterator<PoulesType>>;
}

export interface TournamentConnection {
  pageInfo: PageInfo;
  edges: TournamentEdge[];
}

export interface TournamentConnectionPromise
  extends Promise<TournamentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TournamentEdge>>() => T;
  aggregate: <T = AggregateTournamentPromise>() => T;
}

export interface TournamentConnectionSubscription
  extends Promise<AsyncIterator<TournamentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TournamentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTournamentSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface PlayerEdge {
  node: Player;
  cursor: String;
}

export interface PlayerEdgePromise extends Promise<PlayerEdge>, Fragmentable {
  node: <T = PlayerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlayerEdgeSubscription
  extends Promise<AsyncIterator<PlayerEdge>>,
    Fragmentable {
  node: <T = PlayerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePoule {
  count: Int;
}

export interface AggregatePoulePromise
  extends Promise<AggregatePoule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePouleSubscription
  extends Promise<AsyncIterator<AggregatePoule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "PoulesType",
    embedded: false
  },
  {
    name: "Academy",
    embedded: false
  },
  {
    name: "Clan",
    embedded: false
  },
  {
    name: "Form",
    embedded: false
  },
  {
    name: "Poule",
    embedded: false
  },
  {
    name: "Player",
    embedded: false
  },
  {
    name: "School",
    embedded: false
  },
  {
    name: "Tournament",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
