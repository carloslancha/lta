module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Academy {
  country: String!
  createdBy: User
  id: ID!
  name: String!
  schools(where: SchoolWhereInput, orderBy: SchoolOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [School!]
}

type AcademyConnection {
  pageInfo: PageInfo!
  edges: [AcademyEdge]!
  aggregate: AggregateAcademy!
}

input AcademyCreateInput {
  country: String!
  createdBy: UserCreateOneWithoutAcademiesInput
  id: ID
  name: String!
  schools: SchoolCreateManyWithoutAcademyInput
}

input AcademyCreateManyWithoutCreatedByInput {
  create: [AcademyCreateWithoutCreatedByInput!]
  connect: [AcademyWhereUniqueInput!]
}

input AcademyCreateOneWithoutSchoolsInput {
  create: AcademyCreateWithoutSchoolsInput
  connect: AcademyWhereUniqueInput
}

input AcademyCreateWithoutCreatedByInput {
  country: String!
  id: ID
  name: String!
  schools: SchoolCreateManyWithoutAcademyInput
}

input AcademyCreateWithoutSchoolsInput {
  country: String!
  createdBy: UserCreateOneWithoutAcademiesInput
  id: ID
  name: String!
}

type AcademyEdge {
  node: Academy!
  cursor: String!
}

enum AcademyOrderByInput {
  country_ASC
  country_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type AcademyPreviousValues {
  country: String!
  id: ID!
  name: String!
}

input AcademyScalarWhereInput {
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [AcademyScalarWhereInput!]
  OR: [AcademyScalarWhereInput!]
  NOT: [AcademyScalarWhereInput!]
}

type AcademySubscriptionPayload {
  mutation: MutationType!
  node: Academy
  updatedFields: [String!]
  previousValues: AcademyPreviousValues
}

input AcademySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AcademyWhereInput
  AND: [AcademySubscriptionWhereInput!]
  OR: [AcademySubscriptionWhereInput!]
  NOT: [AcademySubscriptionWhereInput!]
}

input AcademyUpdateInput {
  country: String
  createdBy: UserUpdateOneWithoutAcademiesInput
  name: String
  schools: SchoolUpdateManyWithoutAcademyInput
}

input AcademyUpdateManyDataInput {
  country: String
  name: String
}

input AcademyUpdateManyMutationInput {
  country: String
  name: String
}

input AcademyUpdateManyWithoutCreatedByInput {
  create: [AcademyCreateWithoutCreatedByInput!]
  delete: [AcademyWhereUniqueInput!]
  connect: [AcademyWhereUniqueInput!]
  set: [AcademyWhereUniqueInput!]
  disconnect: [AcademyWhereUniqueInput!]
  update: [AcademyUpdateWithWhereUniqueWithoutCreatedByInput!]
  upsert: [AcademyUpsertWithWhereUniqueWithoutCreatedByInput!]
  deleteMany: [AcademyScalarWhereInput!]
  updateMany: [AcademyUpdateManyWithWhereNestedInput!]
}

input AcademyUpdateManyWithWhereNestedInput {
  where: AcademyScalarWhereInput!
  data: AcademyUpdateManyDataInput!
}

input AcademyUpdateOneRequiredWithoutSchoolsInput {
  create: AcademyCreateWithoutSchoolsInput
  update: AcademyUpdateWithoutSchoolsDataInput
  upsert: AcademyUpsertWithoutSchoolsInput
  connect: AcademyWhereUniqueInput
}

input AcademyUpdateWithoutCreatedByDataInput {
  country: String
  name: String
  schools: SchoolUpdateManyWithoutAcademyInput
}

input AcademyUpdateWithoutSchoolsDataInput {
  country: String
  createdBy: UserUpdateOneWithoutAcademiesInput
  name: String
}

input AcademyUpdateWithWhereUniqueWithoutCreatedByInput {
  where: AcademyWhereUniqueInput!
  data: AcademyUpdateWithoutCreatedByDataInput!
}

input AcademyUpsertWithoutSchoolsInput {
  update: AcademyUpdateWithoutSchoolsDataInput!
  create: AcademyCreateWithoutSchoolsInput!
}

input AcademyUpsertWithWhereUniqueWithoutCreatedByInput {
  where: AcademyWhereUniqueInput!
  update: AcademyUpdateWithoutCreatedByDataInput!
  create: AcademyCreateWithoutCreatedByInput!
}

input AcademyWhereInput {
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  createdBy: UserWhereInput
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  schools_every: SchoolWhereInput
  schools_some: SchoolWhereInput
  schools_none: SchoolWhereInput
  AND: [AcademyWhereInput!]
  OR: [AcademyWhereInput!]
  NOT: [AcademyWhereInput!]
}

input AcademyWhereUniqueInput {
  id: ID
  name: String
}

type AggregateAcademy {
  count: Int!
}

type AggregateAssault {
  count: Int!
}

type AggregateCard {
  count: Int!
}

type AggregateClan {
  count: Int!
}

type AggregateForm {
  count: Int!
}

type AggregateMatch {
  count: Int!
}

type AggregatePlayer {
  count: Int!
}

type AggregatePoule {
  count: Int!
}

type AggregateRound {
  count: Int!
}

type AggregateSchool {
  count: Int!
}

type AggregateTournament {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Assault {
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card!]
  doppio: Boolean
  id: ID!
  match: Match
  nullo: Boolean
  number: Int!
  winner: Player
}

type AssaultConnection {
  pageInfo: PageInfo!
  edges: [AssaultEdge]!
  aggregate: AggregateAssault!
}

input AssaultCreateInput {
  cards: CardCreateManyWithoutAssaultInput
  doppio: Boolean
  id: ID
  match: MatchCreateOneWithoutAssaultsInput
  nullo: Boolean
  number: Int!
  winner: PlayerCreateOneWithoutAssaultsWonInput
}

input AssaultCreateManyWithoutMatchInput {
  create: [AssaultCreateWithoutMatchInput!]
  connect: [AssaultWhereUniqueInput!]
}

input AssaultCreateManyWithoutWinnerInput {
  create: [AssaultCreateWithoutWinnerInput!]
  connect: [AssaultWhereUniqueInput!]
}

input AssaultCreateOneWithoutCardsInput {
  create: AssaultCreateWithoutCardsInput
  connect: AssaultWhereUniqueInput
}

input AssaultCreateWithoutCardsInput {
  doppio: Boolean
  id: ID
  match: MatchCreateOneWithoutAssaultsInput
  nullo: Boolean
  number: Int!
  winner: PlayerCreateOneWithoutAssaultsWonInput
}

input AssaultCreateWithoutMatchInput {
  cards: CardCreateManyWithoutAssaultInput
  doppio: Boolean
  id: ID
  nullo: Boolean
  number: Int!
  winner: PlayerCreateOneWithoutAssaultsWonInput
}

input AssaultCreateWithoutWinnerInput {
  cards: CardCreateManyWithoutAssaultInput
  doppio: Boolean
  id: ID
  match: MatchCreateOneWithoutAssaultsInput
  nullo: Boolean
  number: Int!
}

type AssaultEdge {
  node: Assault!
  cursor: String!
}

enum AssaultOrderByInput {
  doppio_ASC
  doppio_DESC
  id_ASC
  id_DESC
  nullo_ASC
  nullo_DESC
  number_ASC
  number_DESC
}

type AssaultPreviousValues {
  doppio: Boolean
  id: ID!
  nullo: Boolean
  number: Int!
}

input AssaultScalarWhereInput {
  doppio: Boolean
  doppio_not: Boolean
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  nullo: Boolean
  nullo_not: Boolean
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  AND: [AssaultScalarWhereInput!]
  OR: [AssaultScalarWhereInput!]
  NOT: [AssaultScalarWhereInput!]
}

type AssaultSubscriptionPayload {
  mutation: MutationType!
  node: Assault
  updatedFields: [String!]
  previousValues: AssaultPreviousValues
}

input AssaultSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AssaultWhereInput
  AND: [AssaultSubscriptionWhereInput!]
  OR: [AssaultSubscriptionWhereInput!]
  NOT: [AssaultSubscriptionWhereInput!]
}

input AssaultUpdateInput {
  cards: CardUpdateManyWithoutAssaultInput
  doppio: Boolean
  match: MatchUpdateOneWithoutAssaultsInput
  nullo: Boolean
  number: Int
  winner: PlayerUpdateOneWithoutAssaultsWonInput
}

input AssaultUpdateManyDataInput {
  doppio: Boolean
  nullo: Boolean
  number: Int
}

input AssaultUpdateManyMutationInput {
  doppio: Boolean
  nullo: Boolean
  number: Int
}

input AssaultUpdateManyWithoutMatchInput {
  create: [AssaultCreateWithoutMatchInput!]
  delete: [AssaultWhereUniqueInput!]
  connect: [AssaultWhereUniqueInput!]
  set: [AssaultWhereUniqueInput!]
  disconnect: [AssaultWhereUniqueInput!]
  update: [AssaultUpdateWithWhereUniqueWithoutMatchInput!]
  upsert: [AssaultUpsertWithWhereUniqueWithoutMatchInput!]
  deleteMany: [AssaultScalarWhereInput!]
  updateMany: [AssaultUpdateManyWithWhereNestedInput!]
}

input AssaultUpdateManyWithoutWinnerInput {
  create: [AssaultCreateWithoutWinnerInput!]
  delete: [AssaultWhereUniqueInput!]
  connect: [AssaultWhereUniqueInput!]
  set: [AssaultWhereUniqueInput!]
  disconnect: [AssaultWhereUniqueInput!]
  update: [AssaultUpdateWithWhereUniqueWithoutWinnerInput!]
  upsert: [AssaultUpsertWithWhereUniqueWithoutWinnerInput!]
  deleteMany: [AssaultScalarWhereInput!]
  updateMany: [AssaultUpdateManyWithWhereNestedInput!]
}

input AssaultUpdateManyWithWhereNestedInput {
  where: AssaultScalarWhereInput!
  data: AssaultUpdateManyDataInput!
}

input AssaultUpdateOneRequiredWithoutCardsInput {
  create: AssaultCreateWithoutCardsInput
  update: AssaultUpdateWithoutCardsDataInput
  upsert: AssaultUpsertWithoutCardsInput
  connect: AssaultWhereUniqueInput
}

input AssaultUpdateWithoutCardsDataInput {
  doppio: Boolean
  match: MatchUpdateOneWithoutAssaultsInput
  nullo: Boolean
  number: Int
  winner: PlayerUpdateOneWithoutAssaultsWonInput
}

input AssaultUpdateWithoutMatchDataInput {
  cards: CardUpdateManyWithoutAssaultInput
  doppio: Boolean
  nullo: Boolean
  number: Int
  winner: PlayerUpdateOneWithoutAssaultsWonInput
}

input AssaultUpdateWithoutWinnerDataInput {
  cards: CardUpdateManyWithoutAssaultInput
  doppio: Boolean
  match: MatchUpdateOneWithoutAssaultsInput
  nullo: Boolean
  number: Int
}

input AssaultUpdateWithWhereUniqueWithoutMatchInput {
  where: AssaultWhereUniqueInput!
  data: AssaultUpdateWithoutMatchDataInput!
}

input AssaultUpdateWithWhereUniqueWithoutWinnerInput {
  where: AssaultWhereUniqueInput!
  data: AssaultUpdateWithoutWinnerDataInput!
}

input AssaultUpsertWithoutCardsInput {
  update: AssaultUpdateWithoutCardsDataInput!
  create: AssaultCreateWithoutCardsInput!
}

input AssaultUpsertWithWhereUniqueWithoutMatchInput {
  where: AssaultWhereUniqueInput!
  update: AssaultUpdateWithoutMatchDataInput!
  create: AssaultCreateWithoutMatchInput!
}

input AssaultUpsertWithWhereUniqueWithoutWinnerInput {
  where: AssaultWhereUniqueInput!
  update: AssaultUpdateWithoutWinnerDataInput!
  create: AssaultCreateWithoutWinnerInput!
}

input AssaultWhereInput {
  cards_every: CardWhereInput
  cards_some: CardWhereInput
  cards_none: CardWhereInput
  doppio: Boolean
  doppio_not: Boolean
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  match: MatchWhereInput
  nullo: Boolean
  nullo_not: Boolean
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  winner: PlayerWhereInput
  AND: [AssaultWhereInput!]
  OR: [AssaultWhereInput!]
  NOT: [AssaultWhereInput!]
}

input AssaultWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Card {
  assault: Assault!
  id: ID!
  reason: String
  type: CardsType!
  player: Player!
}

type CardConnection {
  pageInfo: PageInfo!
  edges: [CardEdge]!
  aggregate: AggregateCard!
}

input CardCreateInput {
  assault: AssaultCreateOneWithoutCardsInput!
  id: ID
  reason: String
  type: CardsType!
  player: PlayerCreateOneWithoutCardsInput!
}

input CardCreateManyWithoutAssaultInput {
  create: [CardCreateWithoutAssaultInput!]
  connect: [CardWhereUniqueInput!]
}

input CardCreateManyWithoutPlayerInput {
  create: [CardCreateWithoutPlayerInput!]
  connect: [CardWhereUniqueInput!]
}

input CardCreateWithoutAssaultInput {
  id: ID
  reason: String
  type: CardsType!
  player: PlayerCreateOneWithoutCardsInput!
}

input CardCreateWithoutPlayerInput {
  assault: AssaultCreateOneWithoutCardsInput!
  id: ID
  reason: String
  type: CardsType!
}

type CardEdge {
  node: Card!
  cursor: String!
}

enum CardOrderByInput {
  id_ASC
  id_DESC
  reason_ASC
  reason_DESC
  type_ASC
  type_DESC
}

type CardPreviousValues {
  id: ID!
  reason: String
  type: CardsType!
}

input CardScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  reason: String
  reason_not: String
  reason_in: [String!]
  reason_not_in: [String!]
  reason_lt: String
  reason_lte: String
  reason_gt: String
  reason_gte: String
  reason_contains: String
  reason_not_contains: String
  reason_starts_with: String
  reason_not_starts_with: String
  reason_ends_with: String
  reason_not_ends_with: String
  type: CardsType
  type_not: CardsType
  type_in: [CardsType!]
  type_not_in: [CardsType!]
  AND: [CardScalarWhereInput!]
  OR: [CardScalarWhereInput!]
  NOT: [CardScalarWhereInput!]
}

enum CardsType {
  WHITE
  YELLOW
  RED
  BLACK
}

type CardSubscriptionPayload {
  mutation: MutationType!
  node: Card
  updatedFields: [String!]
  previousValues: CardPreviousValues
}

input CardSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CardWhereInput
  AND: [CardSubscriptionWhereInput!]
  OR: [CardSubscriptionWhereInput!]
  NOT: [CardSubscriptionWhereInput!]
}

input CardUpdateInput {
  assault: AssaultUpdateOneRequiredWithoutCardsInput
  reason: String
  type: CardsType
  player: PlayerUpdateOneRequiredWithoutCardsInput
}

input CardUpdateManyDataInput {
  reason: String
  type: CardsType
}

input CardUpdateManyMutationInput {
  reason: String
  type: CardsType
}

input CardUpdateManyWithoutAssaultInput {
  create: [CardCreateWithoutAssaultInput!]
  delete: [CardWhereUniqueInput!]
  connect: [CardWhereUniqueInput!]
  set: [CardWhereUniqueInput!]
  disconnect: [CardWhereUniqueInput!]
  update: [CardUpdateWithWhereUniqueWithoutAssaultInput!]
  upsert: [CardUpsertWithWhereUniqueWithoutAssaultInput!]
  deleteMany: [CardScalarWhereInput!]
  updateMany: [CardUpdateManyWithWhereNestedInput!]
}

input CardUpdateManyWithoutPlayerInput {
  create: [CardCreateWithoutPlayerInput!]
  delete: [CardWhereUniqueInput!]
  connect: [CardWhereUniqueInput!]
  set: [CardWhereUniqueInput!]
  disconnect: [CardWhereUniqueInput!]
  update: [CardUpdateWithWhereUniqueWithoutPlayerInput!]
  upsert: [CardUpsertWithWhereUniqueWithoutPlayerInput!]
  deleteMany: [CardScalarWhereInput!]
  updateMany: [CardUpdateManyWithWhereNestedInput!]
}

input CardUpdateManyWithWhereNestedInput {
  where: CardScalarWhereInput!
  data: CardUpdateManyDataInput!
}

input CardUpdateWithoutAssaultDataInput {
  reason: String
  type: CardsType
  player: PlayerUpdateOneRequiredWithoutCardsInput
}

input CardUpdateWithoutPlayerDataInput {
  assault: AssaultUpdateOneRequiredWithoutCardsInput
  reason: String
  type: CardsType
}

input CardUpdateWithWhereUniqueWithoutAssaultInput {
  where: CardWhereUniqueInput!
  data: CardUpdateWithoutAssaultDataInput!
}

input CardUpdateWithWhereUniqueWithoutPlayerInput {
  where: CardWhereUniqueInput!
  data: CardUpdateWithoutPlayerDataInput!
}

input CardUpsertWithWhereUniqueWithoutAssaultInput {
  where: CardWhereUniqueInput!
  update: CardUpdateWithoutAssaultDataInput!
  create: CardCreateWithoutAssaultInput!
}

input CardUpsertWithWhereUniqueWithoutPlayerInput {
  where: CardWhereUniqueInput!
  update: CardUpdateWithoutPlayerDataInput!
  create: CardCreateWithoutPlayerInput!
}

input CardWhereInput {
  assault: AssaultWhereInput
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  reason: String
  reason_not: String
  reason_in: [String!]
  reason_not_in: [String!]
  reason_lt: String
  reason_lte: String
  reason_gt: String
  reason_gte: String
  reason_contains: String
  reason_not_contains: String
  reason_starts_with: String
  reason_not_starts_with: String
  reason_ends_with: String
  reason_not_ends_with: String
  type: CardsType
  type_not: CardsType
  type_in: [CardsType!]
  type_not_in: [CardsType!]
  player: PlayerWhereInput
  AND: [CardWhereInput!]
  OR: [CardWhereInput!]
  NOT: [CardWhereInput!]
}

input CardWhereUniqueInput {
  id: ID
}

type Clan {
  createdBy: User
  id: ID!
  name: String!
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player!]
  school: School!
}

type ClanConnection {
  pageInfo: PageInfo!
  edges: [ClanEdge]!
  aggregate: AggregateClan!
}

input ClanCreateInput {
  createdBy: UserCreateOneWithoutClansInput
  id: ID
  name: String!
  players: PlayerCreateManyWithoutClanInput
  school: SchoolCreateOneWithoutClansInput!
}

input ClanCreateManyWithoutCreatedByInput {
  create: [ClanCreateWithoutCreatedByInput!]
  connect: [ClanWhereUniqueInput!]
}

input ClanCreateManyWithoutSchoolInput {
  create: [ClanCreateWithoutSchoolInput!]
  connect: [ClanWhereUniqueInput!]
}

input ClanCreateOneWithoutPlayersInput {
  create: ClanCreateWithoutPlayersInput
  connect: ClanWhereUniqueInput
}

input ClanCreateWithoutCreatedByInput {
  id: ID
  name: String!
  players: PlayerCreateManyWithoutClanInput
  school: SchoolCreateOneWithoutClansInput!
}

input ClanCreateWithoutPlayersInput {
  createdBy: UserCreateOneWithoutClansInput
  id: ID
  name: String!
  school: SchoolCreateOneWithoutClansInput!
}

input ClanCreateWithoutSchoolInput {
  createdBy: UserCreateOneWithoutClansInput
  id: ID
  name: String!
  players: PlayerCreateManyWithoutClanInput
}

type ClanEdge {
  node: Clan!
  cursor: String!
}

enum ClanOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ClanPreviousValues {
  id: ID!
  name: String!
}

input ClanScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ClanScalarWhereInput!]
  OR: [ClanScalarWhereInput!]
  NOT: [ClanScalarWhereInput!]
}

type ClanSubscriptionPayload {
  mutation: MutationType!
  node: Clan
  updatedFields: [String!]
  previousValues: ClanPreviousValues
}

input ClanSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClanWhereInput
  AND: [ClanSubscriptionWhereInput!]
  OR: [ClanSubscriptionWhereInput!]
  NOT: [ClanSubscriptionWhereInput!]
}

input ClanUpdateInput {
  createdBy: UserUpdateOneWithoutClansInput
  name: String
  players: PlayerUpdateManyWithoutClanInput
  school: SchoolUpdateOneRequiredWithoutClansInput
}

input ClanUpdateManyDataInput {
  name: String
}

input ClanUpdateManyMutationInput {
  name: String
}

input ClanUpdateManyWithoutCreatedByInput {
  create: [ClanCreateWithoutCreatedByInput!]
  delete: [ClanWhereUniqueInput!]
  connect: [ClanWhereUniqueInput!]
  set: [ClanWhereUniqueInput!]
  disconnect: [ClanWhereUniqueInput!]
  update: [ClanUpdateWithWhereUniqueWithoutCreatedByInput!]
  upsert: [ClanUpsertWithWhereUniqueWithoutCreatedByInput!]
  deleteMany: [ClanScalarWhereInput!]
  updateMany: [ClanUpdateManyWithWhereNestedInput!]
}

input ClanUpdateManyWithoutSchoolInput {
  create: [ClanCreateWithoutSchoolInput!]
  delete: [ClanWhereUniqueInput!]
  connect: [ClanWhereUniqueInput!]
  set: [ClanWhereUniqueInput!]
  disconnect: [ClanWhereUniqueInput!]
  update: [ClanUpdateWithWhereUniqueWithoutSchoolInput!]
  upsert: [ClanUpsertWithWhereUniqueWithoutSchoolInput!]
  deleteMany: [ClanScalarWhereInput!]
  updateMany: [ClanUpdateManyWithWhereNestedInput!]
}

input ClanUpdateManyWithWhereNestedInput {
  where: ClanScalarWhereInput!
  data: ClanUpdateManyDataInput!
}

input ClanUpdateOneRequiredWithoutPlayersInput {
  create: ClanCreateWithoutPlayersInput
  update: ClanUpdateWithoutPlayersDataInput
  upsert: ClanUpsertWithoutPlayersInput
  connect: ClanWhereUniqueInput
}

input ClanUpdateWithoutCreatedByDataInput {
  name: String
  players: PlayerUpdateManyWithoutClanInput
  school: SchoolUpdateOneRequiredWithoutClansInput
}

input ClanUpdateWithoutPlayersDataInput {
  createdBy: UserUpdateOneWithoutClansInput
  name: String
  school: SchoolUpdateOneRequiredWithoutClansInput
}

input ClanUpdateWithoutSchoolDataInput {
  createdBy: UserUpdateOneWithoutClansInput
  name: String
  players: PlayerUpdateManyWithoutClanInput
}

input ClanUpdateWithWhereUniqueWithoutCreatedByInput {
  where: ClanWhereUniqueInput!
  data: ClanUpdateWithoutCreatedByDataInput!
}

input ClanUpdateWithWhereUniqueWithoutSchoolInput {
  where: ClanWhereUniqueInput!
  data: ClanUpdateWithoutSchoolDataInput!
}

input ClanUpsertWithoutPlayersInput {
  update: ClanUpdateWithoutPlayersDataInput!
  create: ClanCreateWithoutPlayersInput!
}

input ClanUpsertWithWhereUniqueWithoutCreatedByInput {
  where: ClanWhereUniqueInput!
  update: ClanUpdateWithoutCreatedByDataInput!
  create: ClanCreateWithoutCreatedByInput!
}

input ClanUpsertWithWhereUniqueWithoutSchoolInput {
  where: ClanWhereUniqueInput!
  update: ClanUpdateWithoutSchoolDataInput!
  create: ClanCreateWithoutSchoolInput!
}

input ClanWhereInput {
  createdBy: UserWhereInput
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  players_every: PlayerWhereInput
  players_some: PlayerWhereInput
  players_none: PlayerWhereInput
  school: SchoolWhereInput
  AND: [ClanWhereInput!]
  OR: [ClanWhereInput!]
  NOT: [ClanWhereInput!]
}

input ClanWhereUniqueInput {
  id: ID
}

type Form {
  createdBy: User
  id: ID!
  name: String!
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player!]
}

type FormConnection {
  pageInfo: PageInfo!
  edges: [FormEdge]!
  aggregate: AggregateForm!
}

input FormCreateInput {
  createdBy: UserCreateOneWithoutFormsInput
  id: ID
  name: String!
  players: PlayerCreateManyWithoutFormsInput
}

input FormCreateManyWithoutCreatedByInput {
  create: [FormCreateWithoutCreatedByInput!]
  connect: [FormWhereUniqueInput!]
}

input FormCreateManyWithoutPlayersInput {
  create: [FormCreateWithoutPlayersInput!]
  connect: [FormWhereUniqueInput!]
}

input FormCreateWithoutCreatedByInput {
  id: ID
  name: String!
  players: PlayerCreateManyWithoutFormsInput
}

input FormCreateWithoutPlayersInput {
  createdBy: UserCreateOneWithoutFormsInput
  id: ID
  name: String!
}

type FormEdge {
  node: Form!
  cursor: String!
}

enum FormOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type FormPreviousValues {
  id: ID!
  name: String!
}

input FormScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [FormScalarWhereInput!]
  OR: [FormScalarWhereInput!]
  NOT: [FormScalarWhereInput!]
}

type FormSubscriptionPayload {
  mutation: MutationType!
  node: Form
  updatedFields: [String!]
  previousValues: FormPreviousValues
}

input FormSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FormWhereInput
  AND: [FormSubscriptionWhereInput!]
  OR: [FormSubscriptionWhereInput!]
  NOT: [FormSubscriptionWhereInput!]
}

input FormUpdateInput {
  createdBy: UserUpdateOneWithoutFormsInput
  name: String
  players: PlayerUpdateManyWithoutFormsInput
}

input FormUpdateManyDataInput {
  name: String
}

input FormUpdateManyMutationInput {
  name: String
}

input FormUpdateManyWithoutCreatedByInput {
  create: [FormCreateWithoutCreatedByInput!]
  delete: [FormWhereUniqueInput!]
  connect: [FormWhereUniqueInput!]
  set: [FormWhereUniqueInput!]
  disconnect: [FormWhereUniqueInput!]
  update: [FormUpdateWithWhereUniqueWithoutCreatedByInput!]
  upsert: [FormUpsertWithWhereUniqueWithoutCreatedByInput!]
  deleteMany: [FormScalarWhereInput!]
  updateMany: [FormUpdateManyWithWhereNestedInput!]
}

input FormUpdateManyWithoutPlayersInput {
  create: [FormCreateWithoutPlayersInput!]
  delete: [FormWhereUniqueInput!]
  connect: [FormWhereUniqueInput!]
  set: [FormWhereUniqueInput!]
  disconnect: [FormWhereUniqueInput!]
  update: [FormUpdateWithWhereUniqueWithoutPlayersInput!]
  upsert: [FormUpsertWithWhereUniqueWithoutPlayersInput!]
  deleteMany: [FormScalarWhereInput!]
  updateMany: [FormUpdateManyWithWhereNestedInput!]
}

input FormUpdateManyWithWhereNestedInput {
  where: FormScalarWhereInput!
  data: FormUpdateManyDataInput!
}

input FormUpdateWithoutCreatedByDataInput {
  name: String
  players: PlayerUpdateManyWithoutFormsInput
}

input FormUpdateWithoutPlayersDataInput {
  createdBy: UserUpdateOneWithoutFormsInput
  name: String
}

input FormUpdateWithWhereUniqueWithoutCreatedByInput {
  where: FormWhereUniqueInput!
  data: FormUpdateWithoutCreatedByDataInput!
}

input FormUpdateWithWhereUniqueWithoutPlayersInput {
  where: FormWhereUniqueInput!
  data: FormUpdateWithoutPlayersDataInput!
}

input FormUpsertWithWhereUniqueWithoutCreatedByInput {
  where: FormWhereUniqueInput!
  update: FormUpdateWithoutCreatedByDataInput!
  create: FormCreateWithoutCreatedByInput!
}

input FormUpsertWithWhereUniqueWithoutPlayersInput {
  where: FormWhereUniqueInput!
  update: FormUpdateWithoutPlayersDataInput!
  create: FormCreateWithoutPlayersInput!
}

input FormWhereInput {
  createdBy: UserWhereInput
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  players_every: PlayerWhereInput
  players_some: PlayerWhereInput
  players_none: PlayerWhereInput
  AND: [FormWhereInput!]
  OR: [FormWhereInput!]
  NOT: [FormWhereInput!]
}

input FormWhereUniqueInput {
  id: ID
}

scalar Long

type Match {
  assaults(where: AssaultWhereInput, orderBy: AssaultOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Assault!]
  createdBy: User
  duration: Int
  id: ID!
  order: Int!
  player1: Player
  player2: Player
  resultPlayer1: Int
  resultPlayer2: Int
}

type MatchConnection {
  pageInfo: PageInfo!
  edges: [MatchEdge]!
  aggregate: AggregateMatch!
}

input MatchCreateInput {
  assaults: AssaultCreateManyWithoutMatchInput
  createdBy: UserCreateOneInput
  duration: Int
  id: ID
  order: Int!
  player1: PlayerCreateOneInput
  player2: PlayerCreateOneInput
  resultPlayer1: Int
  resultPlayer2: Int
}

input MatchCreateManyInput {
  create: [MatchCreateInput!]
  connect: [MatchWhereUniqueInput!]
}

input MatchCreateOneWithoutAssaultsInput {
  create: MatchCreateWithoutAssaultsInput
  connect: MatchWhereUniqueInput
}

input MatchCreateWithoutAssaultsInput {
  createdBy: UserCreateOneInput
  duration: Int
  id: ID
  order: Int!
  player1: PlayerCreateOneInput
  player2: PlayerCreateOneInput
  resultPlayer1: Int
  resultPlayer2: Int
}

type MatchEdge {
  node: Match!
  cursor: String!
}

enum MatchOrderByInput {
  duration_ASC
  duration_DESC
  id_ASC
  id_DESC
  order_ASC
  order_DESC
  resultPlayer1_ASC
  resultPlayer1_DESC
  resultPlayer2_ASC
  resultPlayer2_DESC
}

type MatchPreviousValues {
  duration: Int
  id: ID!
  order: Int!
  resultPlayer1: Int
  resultPlayer2: Int
}

input MatchScalarWhereInput {
  duration: Int
  duration_not: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_gt: Int
  duration_gte: Int
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  resultPlayer1: Int
  resultPlayer1_not: Int
  resultPlayer1_in: [Int!]
  resultPlayer1_not_in: [Int!]
  resultPlayer1_lt: Int
  resultPlayer1_lte: Int
  resultPlayer1_gt: Int
  resultPlayer1_gte: Int
  resultPlayer2: Int
  resultPlayer2_not: Int
  resultPlayer2_in: [Int!]
  resultPlayer2_not_in: [Int!]
  resultPlayer2_lt: Int
  resultPlayer2_lte: Int
  resultPlayer2_gt: Int
  resultPlayer2_gte: Int
  AND: [MatchScalarWhereInput!]
  OR: [MatchScalarWhereInput!]
  NOT: [MatchScalarWhereInput!]
}

type MatchSubscriptionPayload {
  mutation: MutationType!
  node: Match
  updatedFields: [String!]
  previousValues: MatchPreviousValues
}

input MatchSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MatchWhereInput
  AND: [MatchSubscriptionWhereInput!]
  OR: [MatchSubscriptionWhereInput!]
  NOT: [MatchSubscriptionWhereInput!]
}

input MatchUpdateDataInput {
  assaults: AssaultUpdateManyWithoutMatchInput
  createdBy: UserUpdateOneInput
  duration: Int
  order: Int
  player1: PlayerUpdateOneInput
  player2: PlayerUpdateOneInput
  resultPlayer1: Int
  resultPlayer2: Int
}

input MatchUpdateInput {
  assaults: AssaultUpdateManyWithoutMatchInput
  createdBy: UserUpdateOneInput
  duration: Int
  order: Int
  player1: PlayerUpdateOneInput
  player2: PlayerUpdateOneInput
  resultPlayer1: Int
  resultPlayer2: Int
}

input MatchUpdateManyDataInput {
  duration: Int
  order: Int
  resultPlayer1: Int
  resultPlayer2: Int
}

input MatchUpdateManyInput {
  create: [MatchCreateInput!]
  update: [MatchUpdateWithWhereUniqueNestedInput!]
  upsert: [MatchUpsertWithWhereUniqueNestedInput!]
  delete: [MatchWhereUniqueInput!]
  connect: [MatchWhereUniqueInput!]
  set: [MatchWhereUniqueInput!]
  disconnect: [MatchWhereUniqueInput!]
  deleteMany: [MatchScalarWhereInput!]
  updateMany: [MatchUpdateManyWithWhereNestedInput!]
}

input MatchUpdateManyMutationInput {
  duration: Int
  order: Int
  resultPlayer1: Int
  resultPlayer2: Int
}

input MatchUpdateManyWithWhereNestedInput {
  where: MatchScalarWhereInput!
  data: MatchUpdateManyDataInput!
}

input MatchUpdateOneWithoutAssaultsInput {
  create: MatchCreateWithoutAssaultsInput
  update: MatchUpdateWithoutAssaultsDataInput
  upsert: MatchUpsertWithoutAssaultsInput
  delete: Boolean
  disconnect: Boolean
  connect: MatchWhereUniqueInput
}

input MatchUpdateWithoutAssaultsDataInput {
  createdBy: UserUpdateOneInput
  duration: Int
  order: Int
  player1: PlayerUpdateOneInput
  player2: PlayerUpdateOneInput
  resultPlayer1: Int
  resultPlayer2: Int
}

input MatchUpdateWithWhereUniqueNestedInput {
  where: MatchWhereUniqueInput!
  data: MatchUpdateDataInput!
}

input MatchUpsertWithoutAssaultsInput {
  update: MatchUpdateWithoutAssaultsDataInput!
  create: MatchCreateWithoutAssaultsInput!
}

input MatchUpsertWithWhereUniqueNestedInput {
  where: MatchWhereUniqueInput!
  update: MatchUpdateDataInput!
  create: MatchCreateInput!
}

input MatchWhereInput {
  assaults_every: AssaultWhereInput
  assaults_some: AssaultWhereInput
  assaults_none: AssaultWhereInput
  createdBy: UserWhereInput
  duration: Int
  duration_not: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_gt: Int
  duration_gte: Int
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  player1: PlayerWhereInput
  player2: PlayerWhereInput
  resultPlayer1: Int
  resultPlayer1_not: Int
  resultPlayer1_in: [Int!]
  resultPlayer1_not_in: [Int!]
  resultPlayer1_lt: Int
  resultPlayer1_lte: Int
  resultPlayer1_gt: Int
  resultPlayer1_gte: Int
  resultPlayer2: Int
  resultPlayer2_not: Int
  resultPlayer2_in: [Int!]
  resultPlayer2_not_in: [Int!]
  resultPlayer2_lt: Int
  resultPlayer2_lte: Int
  resultPlayer2_gt: Int
  resultPlayer2_gte: Int
  AND: [MatchWhereInput!]
  OR: [MatchWhereInput!]
  NOT: [MatchWhereInput!]
}

input MatchWhereUniqueInput {
  id: ID
}

type Mutation {
  createAcademy(data: AcademyCreateInput!): Academy!
  updateAcademy(data: AcademyUpdateInput!, where: AcademyWhereUniqueInput!): Academy
  updateManyAcademies(data: AcademyUpdateManyMutationInput!, where: AcademyWhereInput): BatchPayload!
  upsertAcademy(where: AcademyWhereUniqueInput!, create: AcademyCreateInput!, update: AcademyUpdateInput!): Academy!
  deleteAcademy(where: AcademyWhereUniqueInput!): Academy
  deleteManyAcademies(where: AcademyWhereInput): BatchPayload!
  createAssault(data: AssaultCreateInput!): Assault!
  updateAssault(data: AssaultUpdateInput!, where: AssaultWhereUniqueInput!): Assault
  updateManyAssaults(data: AssaultUpdateManyMutationInput!, where: AssaultWhereInput): BatchPayload!
  upsertAssault(where: AssaultWhereUniqueInput!, create: AssaultCreateInput!, update: AssaultUpdateInput!): Assault!
  deleteAssault(where: AssaultWhereUniqueInput!): Assault
  deleteManyAssaults(where: AssaultWhereInput): BatchPayload!
  createCard(data: CardCreateInput!): Card!
  updateCard(data: CardUpdateInput!, where: CardWhereUniqueInput!): Card
  updateManyCards(data: CardUpdateManyMutationInput!, where: CardWhereInput): BatchPayload!
  upsertCard(where: CardWhereUniqueInput!, create: CardCreateInput!, update: CardUpdateInput!): Card!
  deleteCard(where: CardWhereUniqueInput!): Card
  deleteManyCards(where: CardWhereInput): BatchPayload!
  createClan(data: ClanCreateInput!): Clan!
  updateClan(data: ClanUpdateInput!, where: ClanWhereUniqueInput!): Clan
  updateManyClans(data: ClanUpdateManyMutationInput!, where: ClanWhereInput): BatchPayload!
  upsertClan(where: ClanWhereUniqueInput!, create: ClanCreateInput!, update: ClanUpdateInput!): Clan!
  deleteClan(where: ClanWhereUniqueInput!): Clan
  deleteManyClans(where: ClanWhereInput): BatchPayload!
  createForm(data: FormCreateInput!): Form!
  updateForm(data: FormUpdateInput!, where: FormWhereUniqueInput!): Form
  updateManyForms(data: FormUpdateManyMutationInput!, where: FormWhereInput): BatchPayload!
  upsertForm(where: FormWhereUniqueInput!, create: FormCreateInput!, update: FormUpdateInput!): Form!
  deleteForm(where: FormWhereUniqueInput!): Form
  deleteManyForms(where: FormWhereInput): BatchPayload!
  createMatch(data: MatchCreateInput!): Match!
  updateMatch(data: MatchUpdateInput!, where: MatchWhereUniqueInput!): Match
  updateManyMatches(data: MatchUpdateManyMutationInput!, where: MatchWhereInput): BatchPayload!
  upsertMatch(where: MatchWhereUniqueInput!, create: MatchCreateInput!, update: MatchUpdateInput!): Match!
  deleteMatch(where: MatchWhereUniqueInput!): Match
  deleteManyMatches(where: MatchWhereInput): BatchPayload!
  createPlayer(data: PlayerCreateInput!): Player!
  updatePlayer(data: PlayerUpdateInput!, where: PlayerWhereUniqueInput!): Player
  updateManyPlayers(data: PlayerUpdateManyMutationInput!, where: PlayerWhereInput): BatchPayload!
  upsertPlayer(where: PlayerWhereUniqueInput!, create: PlayerCreateInput!, update: PlayerUpdateInput!): Player!
  deletePlayer(where: PlayerWhereUniqueInput!): Player
  deleteManyPlayers(where: PlayerWhereInput): BatchPayload!
  createPoule(data: PouleCreateInput!): Poule!
  updatePoule(data: PouleUpdateInput!, where: PouleWhereUniqueInput!): Poule
  updateManyPoules(data: PouleUpdateManyMutationInput!, where: PouleWhereInput): BatchPayload!
  upsertPoule(where: PouleWhereUniqueInput!, create: PouleCreateInput!, update: PouleUpdateInput!): Poule!
  deletePoule(where: PouleWhereUniqueInput!): Poule
  deleteManyPoules(where: PouleWhereInput): BatchPayload!
  createRound(data: RoundCreateInput!): Round!
  updateRound(data: RoundUpdateInput!, where: RoundWhereUniqueInput!): Round
  updateManyRounds(data: RoundUpdateManyMutationInput!, where: RoundWhereInput): BatchPayload!
  upsertRound(where: RoundWhereUniqueInput!, create: RoundCreateInput!, update: RoundUpdateInput!): Round!
  deleteRound(where: RoundWhereUniqueInput!): Round
  deleteManyRounds(where: RoundWhereInput): BatchPayload!
  createSchool(data: SchoolCreateInput!): School!
  updateSchool(data: SchoolUpdateInput!, where: SchoolWhereUniqueInput!): School
  updateManySchools(data: SchoolUpdateManyMutationInput!, where: SchoolWhereInput): BatchPayload!
  upsertSchool(where: SchoolWhereUniqueInput!, create: SchoolCreateInput!, update: SchoolUpdateInput!): School!
  deleteSchool(where: SchoolWhereUniqueInput!): School
  deleteManySchools(where: SchoolWhereInput): BatchPayload!
  createTournament(data: TournamentCreateInput!): Tournament!
  updateTournament(data: TournamentUpdateInput!, where: TournamentWhereUniqueInput!): Tournament
  updateManyTournaments(data: TournamentUpdateManyMutationInput!, where: TournamentWhereInput): BatchPayload!
  upsertTournament(where: TournamentWhereUniqueInput!, create: TournamentCreateInput!, update: TournamentUpdateInput!): Tournament!
  deleteTournament(where: TournamentWhereUniqueInput!): Tournament
  deleteManyTournaments(where: TournamentWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Player {
  assaultsWon(where: AssaultWhereInput, orderBy: AssaultOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Assault!]
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card!]
  clan: Clan!
  createdBy: User
  familyName: String!
  forms(where: FormWhereInput, orderBy: FormOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Form!]
  id: ID!
  matches(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Match!]
  name: String!
  nickname: String!
  poules(where: PouleWhereInput, orderBy: PouleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Poule!]
  rounds(where: RoundWhereInput, orderBy: RoundOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Round!]
  tournaments(where: TournamentWhereInput, orderBy: TournamentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tournament!]
}

type PlayerConnection {
  pageInfo: PageInfo!
  edges: [PlayerEdge]!
  aggregate: AggregatePlayer!
}

input PlayerCreateInput {
  assaultsWon: AssaultCreateManyWithoutWinnerInput
  cards: CardCreateManyWithoutPlayerInput
  clan: ClanCreateOneWithoutPlayersInput!
  createdBy: UserCreateOneWithoutPlayersInput
  familyName: String!
  forms: FormCreateManyWithoutPlayersInput
  id: ID
  matches: MatchCreateManyInput
  name: String!
  nickname: String!
  poules: PouleCreateManyWithoutPlayersInput
  rounds: RoundCreateManyWithoutPlayersInput
  tournaments: TournamentCreateManyWithoutPlayersInput
}

input PlayerCreateManyWithoutClanInput {
  create: [PlayerCreateWithoutClanInput!]
  connect: [PlayerWhereUniqueInput!]
}

input PlayerCreateManyWithoutCreatedByInput {
  create: [PlayerCreateWithoutCreatedByInput!]
  connect: [PlayerWhereUniqueInput!]
}

input PlayerCreateManyWithoutFormsInput {
  create: [PlayerCreateWithoutFormsInput!]
  connect: [PlayerWhereUniqueInput!]
}

input PlayerCreateManyWithoutPoulesInput {
  create: [PlayerCreateWithoutPoulesInput!]
  connect: [PlayerWhereUniqueInput!]
}

input PlayerCreateManyWithoutRoundsInput {
  create: [PlayerCreateWithoutRoundsInput!]
  connect: [PlayerWhereUniqueInput!]
}

input PlayerCreateManyWithoutTournamentsInput {
  create: [PlayerCreateWithoutTournamentsInput!]
  connect: [PlayerWhereUniqueInput!]
}

input PlayerCreateOneInput {
  create: PlayerCreateInput
  connect: PlayerWhereUniqueInput
}

input PlayerCreateOneWithoutAssaultsWonInput {
  create: PlayerCreateWithoutAssaultsWonInput
  connect: PlayerWhereUniqueInput
}

input PlayerCreateOneWithoutCardsInput {
  create: PlayerCreateWithoutCardsInput
  connect: PlayerWhereUniqueInput
}

input PlayerCreateWithoutAssaultsWonInput {
  cards: CardCreateManyWithoutPlayerInput
  clan: ClanCreateOneWithoutPlayersInput!
  createdBy: UserCreateOneWithoutPlayersInput
  familyName: String!
  forms: FormCreateManyWithoutPlayersInput
  id: ID
  matches: MatchCreateManyInput
  name: String!
  nickname: String!
  poules: PouleCreateManyWithoutPlayersInput
  rounds: RoundCreateManyWithoutPlayersInput
  tournaments: TournamentCreateManyWithoutPlayersInput
}

input PlayerCreateWithoutCardsInput {
  assaultsWon: AssaultCreateManyWithoutWinnerInput
  clan: ClanCreateOneWithoutPlayersInput!
  createdBy: UserCreateOneWithoutPlayersInput
  familyName: String!
  forms: FormCreateManyWithoutPlayersInput
  id: ID
  matches: MatchCreateManyInput
  name: String!
  nickname: String!
  poules: PouleCreateManyWithoutPlayersInput
  rounds: RoundCreateManyWithoutPlayersInput
  tournaments: TournamentCreateManyWithoutPlayersInput
}

input PlayerCreateWithoutClanInput {
  assaultsWon: AssaultCreateManyWithoutWinnerInput
  cards: CardCreateManyWithoutPlayerInput
  createdBy: UserCreateOneWithoutPlayersInput
  familyName: String!
  forms: FormCreateManyWithoutPlayersInput
  id: ID
  matches: MatchCreateManyInput
  name: String!
  nickname: String!
  poules: PouleCreateManyWithoutPlayersInput
  rounds: RoundCreateManyWithoutPlayersInput
  tournaments: TournamentCreateManyWithoutPlayersInput
}

input PlayerCreateWithoutCreatedByInput {
  assaultsWon: AssaultCreateManyWithoutWinnerInput
  cards: CardCreateManyWithoutPlayerInput
  clan: ClanCreateOneWithoutPlayersInput!
  familyName: String!
  forms: FormCreateManyWithoutPlayersInput
  id: ID
  matches: MatchCreateManyInput
  name: String!
  nickname: String!
  poules: PouleCreateManyWithoutPlayersInput
  rounds: RoundCreateManyWithoutPlayersInput
  tournaments: TournamentCreateManyWithoutPlayersInput
}

input PlayerCreateWithoutFormsInput {
  assaultsWon: AssaultCreateManyWithoutWinnerInput
  cards: CardCreateManyWithoutPlayerInput
  clan: ClanCreateOneWithoutPlayersInput!
  createdBy: UserCreateOneWithoutPlayersInput
  familyName: String!
  id: ID
  matches: MatchCreateManyInput
  name: String!
  nickname: String!
  poules: PouleCreateManyWithoutPlayersInput
  rounds: RoundCreateManyWithoutPlayersInput
  tournaments: TournamentCreateManyWithoutPlayersInput
}

input PlayerCreateWithoutPoulesInput {
  assaultsWon: AssaultCreateManyWithoutWinnerInput
  cards: CardCreateManyWithoutPlayerInput
  clan: ClanCreateOneWithoutPlayersInput!
  createdBy: UserCreateOneWithoutPlayersInput
  familyName: String!
  forms: FormCreateManyWithoutPlayersInput
  id: ID
  matches: MatchCreateManyInput
  name: String!
  nickname: String!
  rounds: RoundCreateManyWithoutPlayersInput
  tournaments: TournamentCreateManyWithoutPlayersInput
}

input PlayerCreateWithoutRoundsInput {
  assaultsWon: AssaultCreateManyWithoutWinnerInput
  cards: CardCreateManyWithoutPlayerInput
  clan: ClanCreateOneWithoutPlayersInput!
  createdBy: UserCreateOneWithoutPlayersInput
  familyName: String!
  forms: FormCreateManyWithoutPlayersInput
  id: ID
  matches: MatchCreateManyInput
  name: String!
  nickname: String!
  poules: PouleCreateManyWithoutPlayersInput
  tournaments: TournamentCreateManyWithoutPlayersInput
}

input PlayerCreateWithoutTournamentsInput {
  assaultsWon: AssaultCreateManyWithoutWinnerInput
  cards: CardCreateManyWithoutPlayerInput
  clan: ClanCreateOneWithoutPlayersInput!
  createdBy: UserCreateOneWithoutPlayersInput
  familyName: String!
  forms: FormCreateManyWithoutPlayersInput
  id: ID
  matches: MatchCreateManyInput
  name: String!
  nickname: String!
  poules: PouleCreateManyWithoutPlayersInput
  rounds: RoundCreateManyWithoutPlayersInput
}

type PlayerEdge {
  node: Player!
  cursor: String!
}

enum PlayerOrderByInput {
  familyName_ASC
  familyName_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  nickname_ASC
  nickname_DESC
}

type PlayerPreviousValues {
  familyName: String!
  id: ID!
  name: String!
  nickname: String!
}

input PlayerScalarWhereInput {
  familyName: String
  familyName_not: String
  familyName_in: [String!]
  familyName_not_in: [String!]
  familyName_lt: String
  familyName_lte: String
  familyName_gt: String
  familyName_gte: String
  familyName_contains: String
  familyName_not_contains: String
  familyName_starts_with: String
  familyName_not_starts_with: String
  familyName_ends_with: String
  familyName_not_ends_with: String
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  nickname: String
  nickname_not: String
  nickname_in: [String!]
  nickname_not_in: [String!]
  nickname_lt: String
  nickname_lte: String
  nickname_gt: String
  nickname_gte: String
  nickname_contains: String
  nickname_not_contains: String
  nickname_starts_with: String
  nickname_not_starts_with: String
  nickname_ends_with: String
  nickname_not_ends_with: String
  AND: [PlayerScalarWhereInput!]
  OR: [PlayerScalarWhereInput!]
  NOT: [PlayerScalarWhereInput!]
}

type PlayerSubscriptionPayload {
  mutation: MutationType!
  node: Player
  updatedFields: [String!]
  previousValues: PlayerPreviousValues
}

input PlayerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlayerWhereInput
  AND: [PlayerSubscriptionWhereInput!]
  OR: [PlayerSubscriptionWhereInput!]
  NOT: [PlayerSubscriptionWhereInput!]
}

input PlayerUpdateDataInput {
  assaultsWon: AssaultUpdateManyWithoutWinnerInput
  cards: CardUpdateManyWithoutPlayerInput
  clan: ClanUpdateOneRequiredWithoutPlayersInput
  createdBy: UserUpdateOneWithoutPlayersInput
  familyName: String
  forms: FormUpdateManyWithoutPlayersInput
  matches: MatchUpdateManyInput
  name: String
  nickname: String
  poules: PouleUpdateManyWithoutPlayersInput
  rounds: RoundUpdateManyWithoutPlayersInput
  tournaments: TournamentUpdateManyWithoutPlayersInput
}

input PlayerUpdateInput {
  assaultsWon: AssaultUpdateManyWithoutWinnerInput
  cards: CardUpdateManyWithoutPlayerInput
  clan: ClanUpdateOneRequiredWithoutPlayersInput
  createdBy: UserUpdateOneWithoutPlayersInput
  familyName: String
  forms: FormUpdateManyWithoutPlayersInput
  matches: MatchUpdateManyInput
  name: String
  nickname: String
  poules: PouleUpdateManyWithoutPlayersInput
  rounds: RoundUpdateManyWithoutPlayersInput
  tournaments: TournamentUpdateManyWithoutPlayersInput
}

input PlayerUpdateManyDataInput {
  familyName: String
  name: String
  nickname: String
}

input PlayerUpdateManyMutationInput {
  familyName: String
  name: String
  nickname: String
}

input PlayerUpdateManyWithoutClanInput {
  create: [PlayerCreateWithoutClanInput!]
  delete: [PlayerWhereUniqueInput!]
  connect: [PlayerWhereUniqueInput!]
  set: [PlayerWhereUniqueInput!]
  disconnect: [PlayerWhereUniqueInput!]
  update: [PlayerUpdateWithWhereUniqueWithoutClanInput!]
  upsert: [PlayerUpsertWithWhereUniqueWithoutClanInput!]
  deleteMany: [PlayerScalarWhereInput!]
  updateMany: [PlayerUpdateManyWithWhereNestedInput!]
}

input PlayerUpdateManyWithoutCreatedByInput {
  create: [PlayerCreateWithoutCreatedByInput!]
  delete: [PlayerWhereUniqueInput!]
  connect: [PlayerWhereUniqueInput!]
  set: [PlayerWhereUniqueInput!]
  disconnect: [PlayerWhereUniqueInput!]
  update: [PlayerUpdateWithWhereUniqueWithoutCreatedByInput!]
  upsert: [PlayerUpsertWithWhereUniqueWithoutCreatedByInput!]
  deleteMany: [PlayerScalarWhereInput!]
  updateMany: [PlayerUpdateManyWithWhereNestedInput!]
}

input PlayerUpdateManyWithoutFormsInput {
  create: [PlayerCreateWithoutFormsInput!]
  delete: [PlayerWhereUniqueInput!]
  connect: [PlayerWhereUniqueInput!]
  set: [PlayerWhereUniqueInput!]
  disconnect: [PlayerWhereUniqueInput!]
  update: [PlayerUpdateWithWhereUniqueWithoutFormsInput!]
  upsert: [PlayerUpsertWithWhereUniqueWithoutFormsInput!]
  deleteMany: [PlayerScalarWhereInput!]
  updateMany: [PlayerUpdateManyWithWhereNestedInput!]
}

input PlayerUpdateManyWithoutPoulesInput {
  create: [PlayerCreateWithoutPoulesInput!]
  delete: [PlayerWhereUniqueInput!]
  connect: [PlayerWhereUniqueInput!]
  set: [PlayerWhereUniqueInput!]
  disconnect: [PlayerWhereUniqueInput!]
  update: [PlayerUpdateWithWhereUniqueWithoutPoulesInput!]
  upsert: [PlayerUpsertWithWhereUniqueWithoutPoulesInput!]
  deleteMany: [PlayerScalarWhereInput!]
  updateMany: [PlayerUpdateManyWithWhereNestedInput!]
}

input PlayerUpdateManyWithoutRoundsInput {
  create: [PlayerCreateWithoutRoundsInput!]
  delete: [PlayerWhereUniqueInput!]
  connect: [PlayerWhereUniqueInput!]
  set: [PlayerWhereUniqueInput!]
  disconnect: [PlayerWhereUniqueInput!]
  update: [PlayerUpdateWithWhereUniqueWithoutRoundsInput!]
  upsert: [PlayerUpsertWithWhereUniqueWithoutRoundsInput!]
  deleteMany: [PlayerScalarWhereInput!]
  updateMany: [PlayerUpdateManyWithWhereNestedInput!]
}

input PlayerUpdateManyWithoutTournamentsInput {
  create: [PlayerCreateWithoutTournamentsInput!]
  delete: [PlayerWhereUniqueInput!]
  connect: [PlayerWhereUniqueInput!]
  set: [PlayerWhereUniqueInput!]
  disconnect: [PlayerWhereUniqueInput!]
  update: [PlayerUpdateWithWhereUniqueWithoutTournamentsInput!]
  upsert: [PlayerUpsertWithWhereUniqueWithoutTournamentsInput!]
  deleteMany: [PlayerScalarWhereInput!]
  updateMany: [PlayerUpdateManyWithWhereNestedInput!]
}

input PlayerUpdateManyWithWhereNestedInput {
  where: PlayerScalarWhereInput!
  data: PlayerUpdateManyDataInput!
}

input PlayerUpdateOneInput {
  create: PlayerCreateInput
  update: PlayerUpdateDataInput
  upsert: PlayerUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PlayerWhereUniqueInput
}

input PlayerUpdateOneRequiredWithoutCardsInput {
  create: PlayerCreateWithoutCardsInput
  update: PlayerUpdateWithoutCardsDataInput
  upsert: PlayerUpsertWithoutCardsInput
  connect: PlayerWhereUniqueInput
}

input PlayerUpdateOneWithoutAssaultsWonInput {
  create: PlayerCreateWithoutAssaultsWonInput
  update: PlayerUpdateWithoutAssaultsWonDataInput
  upsert: PlayerUpsertWithoutAssaultsWonInput
  delete: Boolean
  disconnect: Boolean
  connect: PlayerWhereUniqueInput
}

input PlayerUpdateWithoutAssaultsWonDataInput {
  cards: CardUpdateManyWithoutPlayerInput
  clan: ClanUpdateOneRequiredWithoutPlayersInput
  createdBy: UserUpdateOneWithoutPlayersInput
  familyName: String
  forms: FormUpdateManyWithoutPlayersInput
  matches: MatchUpdateManyInput
  name: String
  nickname: String
  poules: PouleUpdateManyWithoutPlayersInput
  rounds: RoundUpdateManyWithoutPlayersInput
  tournaments: TournamentUpdateManyWithoutPlayersInput
}

input PlayerUpdateWithoutCardsDataInput {
  assaultsWon: AssaultUpdateManyWithoutWinnerInput
  clan: ClanUpdateOneRequiredWithoutPlayersInput
  createdBy: UserUpdateOneWithoutPlayersInput
  familyName: String
  forms: FormUpdateManyWithoutPlayersInput
  matches: MatchUpdateManyInput
  name: String
  nickname: String
  poules: PouleUpdateManyWithoutPlayersInput
  rounds: RoundUpdateManyWithoutPlayersInput
  tournaments: TournamentUpdateManyWithoutPlayersInput
}

input PlayerUpdateWithoutClanDataInput {
  assaultsWon: AssaultUpdateManyWithoutWinnerInput
  cards: CardUpdateManyWithoutPlayerInput
  createdBy: UserUpdateOneWithoutPlayersInput
  familyName: String
  forms: FormUpdateManyWithoutPlayersInput
  matches: MatchUpdateManyInput
  name: String
  nickname: String
  poules: PouleUpdateManyWithoutPlayersInput
  rounds: RoundUpdateManyWithoutPlayersInput
  tournaments: TournamentUpdateManyWithoutPlayersInput
}

input PlayerUpdateWithoutCreatedByDataInput {
  assaultsWon: AssaultUpdateManyWithoutWinnerInput
  cards: CardUpdateManyWithoutPlayerInput
  clan: ClanUpdateOneRequiredWithoutPlayersInput
  familyName: String
  forms: FormUpdateManyWithoutPlayersInput
  matches: MatchUpdateManyInput
  name: String
  nickname: String
  poules: PouleUpdateManyWithoutPlayersInput
  rounds: RoundUpdateManyWithoutPlayersInput
  tournaments: TournamentUpdateManyWithoutPlayersInput
}

input PlayerUpdateWithoutFormsDataInput {
  assaultsWon: AssaultUpdateManyWithoutWinnerInput
  cards: CardUpdateManyWithoutPlayerInput
  clan: ClanUpdateOneRequiredWithoutPlayersInput
  createdBy: UserUpdateOneWithoutPlayersInput
  familyName: String
  matches: MatchUpdateManyInput
  name: String
  nickname: String
  poules: PouleUpdateManyWithoutPlayersInput
  rounds: RoundUpdateManyWithoutPlayersInput
  tournaments: TournamentUpdateManyWithoutPlayersInput
}

input PlayerUpdateWithoutPoulesDataInput {
  assaultsWon: AssaultUpdateManyWithoutWinnerInput
  cards: CardUpdateManyWithoutPlayerInput
  clan: ClanUpdateOneRequiredWithoutPlayersInput
  createdBy: UserUpdateOneWithoutPlayersInput
  familyName: String
  forms: FormUpdateManyWithoutPlayersInput
  matches: MatchUpdateManyInput
  name: String
  nickname: String
  rounds: RoundUpdateManyWithoutPlayersInput
  tournaments: TournamentUpdateManyWithoutPlayersInput
}

input PlayerUpdateWithoutRoundsDataInput {
  assaultsWon: AssaultUpdateManyWithoutWinnerInput
  cards: CardUpdateManyWithoutPlayerInput
  clan: ClanUpdateOneRequiredWithoutPlayersInput
  createdBy: UserUpdateOneWithoutPlayersInput
  familyName: String
  forms: FormUpdateManyWithoutPlayersInput
  matches: MatchUpdateManyInput
  name: String
  nickname: String
  poules: PouleUpdateManyWithoutPlayersInput
  tournaments: TournamentUpdateManyWithoutPlayersInput
}

input PlayerUpdateWithoutTournamentsDataInput {
  assaultsWon: AssaultUpdateManyWithoutWinnerInput
  cards: CardUpdateManyWithoutPlayerInput
  clan: ClanUpdateOneRequiredWithoutPlayersInput
  createdBy: UserUpdateOneWithoutPlayersInput
  familyName: String
  forms: FormUpdateManyWithoutPlayersInput
  matches: MatchUpdateManyInput
  name: String
  nickname: String
  poules: PouleUpdateManyWithoutPlayersInput
  rounds: RoundUpdateManyWithoutPlayersInput
}

input PlayerUpdateWithWhereUniqueWithoutClanInput {
  where: PlayerWhereUniqueInput!
  data: PlayerUpdateWithoutClanDataInput!
}

input PlayerUpdateWithWhereUniqueWithoutCreatedByInput {
  where: PlayerWhereUniqueInput!
  data: PlayerUpdateWithoutCreatedByDataInput!
}

input PlayerUpdateWithWhereUniqueWithoutFormsInput {
  where: PlayerWhereUniqueInput!
  data: PlayerUpdateWithoutFormsDataInput!
}

input PlayerUpdateWithWhereUniqueWithoutPoulesInput {
  where: PlayerWhereUniqueInput!
  data: PlayerUpdateWithoutPoulesDataInput!
}

input PlayerUpdateWithWhereUniqueWithoutRoundsInput {
  where: PlayerWhereUniqueInput!
  data: PlayerUpdateWithoutRoundsDataInput!
}

input PlayerUpdateWithWhereUniqueWithoutTournamentsInput {
  where: PlayerWhereUniqueInput!
  data: PlayerUpdateWithoutTournamentsDataInput!
}

input PlayerUpsertNestedInput {
  update: PlayerUpdateDataInput!
  create: PlayerCreateInput!
}

input PlayerUpsertWithoutAssaultsWonInput {
  update: PlayerUpdateWithoutAssaultsWonDataInput!
  create: PlayerCreateWithoutAssaultsWonInput!
}

input PlayerUpsertWithoutCardsInput {
  update: PlayerUpdateWithoutCardsDataInput!
  create: PlayerCreateWithoutCardsInput!
}

input PlayerUpsertWithWhereUniqueWithoutClanInput {
  where: PlayerWhereUniqueInput!
  update: PlayerUpdateWithoutClanDataInput!
  create: PlayerCreateWithoutClanInput!
}

input PlayerUpsertWithWhereUniqueWithoutCreatedByInput {
  where: PlayerWhereUniqueInput!
  update: PlayerUpdateWithoutCreatedByDataInput!
  create: PlayerCreateWithoutCreatedByInput!
}

input PlayerUpsertWithWhereUniqueWithoutFormsInput {
  where: PlayerWhereUniqueInput!
  update: PlayerUpdateWithoutFormsDataInput!
  create: PlayerCreateWithoutFormsInput!
}

input PlayerUpsertWithWhereUniqueWithoutPoulesInput {
  where: PlayerWhereUniqueInput!
  update: PlayerUpdateWithoutPoulesDataInput!
  create: PlayerCreateWithoutPoulesInput!
}

input PlayerUpsertWithWhereUniqueWithoutRoundsInput {
  where: PlayerWhereUniqueInput!
  update: PlayerUpdateWithoutRoundsDataInput!
  create: PlayerCreateWithoutRoundsInput!
}

input PlayerUpsertWithWhereUniqueWithoutTournamentsInput {
  where: PlayerWhereUniqueInput!
  update: PlayerUpdateWithoutTournamentsDataInput!
  create: PlayerCreateWithoutTournamentsInput!
}

input PlayerWhereInput {
  assaultsWon_every: AssaultWhereInput
  assaultsWon_some: AssaultWhereInput
  assaultsWon_none: AssaultWhereInput
  cards_every: CardWhereInput
  cards_some: CardWhereInput
  cards_none: CardWhereInput
  clan: ClanWhereInput
  createdBy: UserWhereInput
  familyName: String
  familyName_not: String
  familyName_in: [String!]
  familyName_not_in: [String!]
  familyName_lt: String
  familyName_lte: String
  familyName_gt: String
  familyName_gte: String
  familyName_contains: String
  familyName_not_contains: String
  familyName_starts_with: String
  familyName_not_starts_with: String
  familyName_ends_with: String
  familyName_not_ends_with: String
  forms_every: FormWhereInput
  forms_some: FormWhereInput
  forms_none: FormWhereInput
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  matches_every: MatchWhereInput
  matches_some: MatchWhereInput
  matches_none: MatchWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  nickname: String
  nickname_not: String
  nickname_in: [String!]
  nickname_not_in: [String!]
  nickname_lt: String
  nickname_lte: String
  nickname_gt: String
  nickname_gte: String
  nickname_contains: String
  nickname_not_contains: String
  nickname_starts_with: String
  nickname_not_starts_with: String
  nickname_ends_with: String
  nickname_not_ends_with: String
  poules_every: PouleWhereInput
  poules_some: PouleWhereInput
  poules_none: PouleWhereInput
  rounds_every: RoundWhereInput
  rounds_some: RoundWhereInput
  rounds_none: RoundWhereInput
  tournaments_every: TournamentWhereInput
  tournaments_some: TournamentWhereInput
  tournaments_none: TournamentWhereInput
  AND: [PlayerWhereInput!]
  OR: [PlayerWhereInput!]
  NOT: [PlayerWhereInput!]
}

input PlayerWhereUniqueInput {
  id: ID
}

type Poule {
  createdBy: User
  id: ID!
  matches(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Match!]
  name: String!
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player!]
  tournament: Tournament!
}

type PouleConnection {
  pageInfo: PageInfo!
  edges: [PouleEdge]!
  aggregate: AggregatePoule!
}

input PouleCreateInput {
  createdBy: UserCreateOneWithoutPoulesInput
  id: ID
  matches: MatchCreateManyInput
  name: String!
  players: PlayerCreateManyWithoutPoulesInput
  tournament: TournamentCreateOneWithoutPoulesInput!
}

input PouleCreateManyWithoutCreatedByInput {
  create: [PouleCreateWithoutCreatedByInput!]
  connect: [PouleWhereUniqueInput!]
}

input PouleCreateManyWithoutPlayersInput {
  create: [PouleCreateWithoutPlayersInput!]
  connect: [PouleWhereUniqueInput!]
}

input PouleCreateManyWithoutTournamentInput {
  create: [PouleCreateWithoutTournamentInput!]
  connect: [PouleWhereUniqueInput!]
}

input PouleCreateWithoutCreatedByInput {
  id: ID
  matches: MatchCreateManyInput
  name: String!
  players: PlayerCreateManyWithoutPoulesInput
  tournament: TournamentCreateOneWithoutPoulesInput!
}

input PouleCreateWithoutPlayersInput {
  createdBy: UserCreateOneWithoutPoulesInput
  id: ID
  matches: MatchCreateManyInput
  name: String!
  tournament: TournamentCreateOneWithoutPoulesInput!
}

input PouleCreateWithoutTournamentInput {
  createdBy: UserCreateOneWithoutPoulesInput
  id: ID
  matches: MatchCreateManyInput
  name: String!
  players: PlayerCreateManyWithoutPoulesInput
}

type PouleEdge {
  node: Poule!
  cursor: String!
}

enum PouleOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type PoulePreviousValues {
  id: ID!
  name: String!
}

input PouleScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [PouleScalarWhereInput!]
  OR: [PouleScalarWhereInput!]
  NOT: [PouleScalarWhereInput!]
}

enum PoulesType {
  POSITIONING
  QUALIFICATION
}

type PouleSubscriptionPayload {
  mutation: MutationType!
  node: Poule
  updatedFields: [String!]
  previousValues: PoulePreviousValues
}

input PouleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PouleWhereInput
  AND: [PouleSubscriptionWhereInput!]
  OR: [PouleSubscriptionWhereInput!]
  NOT: [PouleSubscriptionWhereInput!]
}

input PouleUpdateInput {
  createdBy: UserUpdateOneWithoutPoulesInput
  matches: MatchUpdateManyInput
  name: String
  players: PlayerUpdateManyWithoutPoulesInput
  tournament: TournamentUpdateOneRequiredWithoutPoulesInput
}

input PouleUpdateManyDataInput {
  name: String
}

input PouleUpdateManyMutationInput {
  name: String
}

input PouleUpdateManyWithoutCreatedByInput {
  create: [PouleCreateWithoutCreatedByInput!]
  delete: [PouleWhereUniqueInput!]
  connect: [PouleWhereUniqueInput!]
  set: [PouleWhereUniqueInput!]
  disconnect: [PouleWhereUniqueInput!]
  update: [PouleUpdateWithWhereUniqueWithoutCreatedByInput!]
  upsert: [PouleUpsertWithWhereUniqueWithoutCreatedByInput!]
  deleteMany: [PouleScalarWhereInput!]
  updateMany: [PouleUpdateManyWithWhereNestedInput!]
}

input PouleUpdateManyWithoutPlayersInput {
  create: [PouleCreateWithoutPlayersInput!]
  delete: [PouleWhereUniqueInput!]
  connect: [PouleWhereUniqueInput!]
  set: [PouleWhereUniqueInput!]
  disconnect: [PouleWhereUniqueInput!]
  update: [PouleUpdateWithWhereUniqueWithoutPlayersInput!]
  upsert: [PouleUpsertWithWhereUniqueWithoutPlayersInput!]
  deleteMany: [PouleScalarWhereInput!]
  updateMany: [PouleUpdateManyWithWhereNestedInput!]
}

input PouleUpdateManyWithoutTournamentInput {
  create: [PouleCreateWithoutTournamentInput!]
  delete: [PouleWhereUniqueInput!]
  connect: [PouleWhereUniqueInput!]
  set: [PouleWhereUniqueInput!]
  disconnect: [PouleWhereUniqueInput!]
  update: [PouleUpdateWithWhereUniqueWithoutTournamentInput!]
  upsert: [PouleUpsertWithWhereUniqueWithoutTournamentInput!]
  deleteMany: [PouleScalarWhereInput!]
  updateMany: [PouleUpdateManyWithWhereNestedInput!]
}

input PouleUpdateManyWithWhereNestedInput {
  where: PouleScalarWhereInput!
  data: PouleUpdateManyDataInput!
}

input PouleUpdateWithoutCreatedByDataInput {
  matches: MatchUpdateManyInput
  name: String
  players: PlayerUpdateManyWithoutPoulesInput
  tournament: TournamentUpdateOneRequiredWithoutPoulesInput
}

input PouleUpdateWithoutPlayersDataInput {
  createdBy: UserUpdateOneWithoutPoulesInput
  matches: MatchUpdateManyInput
  name: String
  tournament: TournamentUpdateOneRequiredWithoutPoulesInput
}

input PouleUpdateWithoutTournamentDataInput {
  createdBy: UserUpdateOneWithoutPoulesInput
  matches: MatchUpdateManyInput
  name: String
  players: PlayerUpdateManyWithoutPoulesInput
}

input PouleUpdateWithWhereUniqueWithoutCreatedByInput {
  where: PouleWhereUniqueInput!
  data: PouleUpdateWithoutCreatedByDataInput!
}

input PouleUpdateWithWhereUniqueWithoutPlayersInput {
  where: PouleWhereUniqueInput!
  data: PouleUpdateWithoutPlayersDataInput!
}

input PouleUpdateWithWhereUniqueWithoutTournamentInput {
  where: PouleWhereUniqueInput!
  data: PouleUpdateWithoutTournamentDataInput!
}

input PouleUpsertWithWhereUniqueWithoutCreatedByInput {
  where: PouleWhereUniqueInput!
  update: PouleUpdateWithoutCreatedByDataInput!
  create: PouleCreateWithoutCreatedByInput!
}

input PouleUpsertWithWhereUniqueWithoutPlayersInput {
  where: PouleWhereUniqueInput!
  update: PouleUpdateWithoutPlayersDataInput!
  create: PouleCreateWithoutPlayersInput!
}

input PouleUpsertWithWhereUniqueWithoutTournamentInput {
  where: PouleWhereUniqueInput!
  update: PouleUpdateWithoutTournamentDataInput!
  create: PouleCreateWithoutTournamentInput!
}

input PouleWhereInput {
  createdBy: UserWhereInput
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  matches_every: MatchWhereInput
  matches_some: MatchWhereInput
  matches_none: MatchWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  players_every: PlayerWhereInput
  players_some: PlayerWhereInput
  players_none: PlayerWhereInput
  tournament: TournamentWhereInput
  AND: [PouleWhereInput!]
  OR: [PouleWhereInput!]
  NOT: [PouleWhereInput!]
}

input PouleWhereUniqueInput {
  id: ID
}

type Query {
  academy(where: AcademyWhereUniqueInput!): Academy
  academies(where: AcademyWhereInput, orderBy: AcademyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Academy]!
  academiesConnection(where: AcademyWhereInput, orderBy: AcademyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AcademyConnection!
  assault(where: AssaultWhereUniqueInput!): Assault
  assaults(where: AssaultWhereInput, orderBy: AssaultOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Assault]!
  assaultsConnection(where: AssaultWhereInput, orderBy: AssaultOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AssaultConnection!
  card(where: CardWhereUniqueInput!): Card
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card]!
  cardsConnection(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CardConnection!
  clan(where: ClanWhereUniqueInput!): Clan
  clans(where: ClanWhereInput, orderBy: ClanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Clan]!
  clansConnection(where: ClanWhereInput, orderBy: ClanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClanConnection!
  form(where: FormWhereUniqueInput!): Form
  forms(where: FormWhereInput, orderBy: FormOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Form]!
  formsConnection(where: FormWhereInput, orderBy: FormOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FormConnection!
  match(where: MatchWhereUniqueInput!): Match
  matches(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Match]!
  matchesConnection(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MatchConnection!
  player(where: PlayerWhereUniqueInput!): Player
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player]!
  playersConnection(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlayerConnection!
  poule(where: PouleWhereUniqueInput!): Poule
  poules(where: PouleWhereInput, orderBy: PouleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Poule]!
  poulesConnection(where: PouleWhereInput, orderBy: PouleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PouleConnection!
  round(where: RoundWhereUniqueInput!): Round
  rounds(where: RoundWhereInput, orderBy: RoundOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Round]!
  roundsConnection(where: RoundWhereInput, orderBy: RoundOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoundConnection!
  school(where: SchoolWhereUniqueInput!): School
  schools(where: SchoolWhereInput, orderBy: SchoolOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [School]!
  schoolsConnection(where: SchoolWhereInput, orderBy: SchoolOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SchoolConnection!
  tournament(where: TournamentWhereUniqueInput!): Tournament
  tournaments(where: TournamentWhereInput, orderBy: TournamentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tournament]!
  tournamentsConnection(where: TournamentWhereInput, orderBy: TournamentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TournamentConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Round {
  createdBy: User
  id: ID!
  matches(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Match!]
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player!]
  roundType: RoundsType!
  tournament: Tournament!
}

type RoundConnection {
  pageInfo: PageInfo!
  edges: [RoundEdge]!
  aggregate: AggregateRound!
}

input RoundCreateInput {
  createdBy: UserCreateOneWithoutRoundsInput
  id: ID
  matches: MatchCreateManyInput
  players: PlayerCreateManyWithoutRoundsInput
  roundType: RoundsType!
  tournament: TournamentCreateOneWithoutRoundsInput!
}

input RoundCreateManyWithoutCreatedByInput {
  create: [RoundCreateWithoutCreatedByInput!]
  connect: [RoundWhereUniqueInput!]
}

input RoundCreateManyWithoutPlayersInput {
  create: [RoundCreateWithoutPlayersInput!]
  connect: [RoundWhereUniqueInput!]
}

input RoundCreateManyWithoutTournamentInput {
  create: [RoundCreateWithoutTournamentInput!]
  connect: [RoundWhereUniqueInput!]
}

input RoundCreateWithoutCreatedByInput {
  id: ID
  matches: MatchCreateManyInput
  players: PlayerCreateManyWithoutRoundsInput
  roundType: RoundsType!
  tournament: TournamentCreateOneWithoutRoundsInput!
}

input RoundCreateWithoutPlayersInput {
  createdBy: UserCreateOneWithoutRoundsInput
  id: ID
  matches: MatchCreateManyInput
  roundType: RoundsType!
  tournament: TournamentCreateOneWithoutRoundsInput!
}

input RoundCreateWithoutTournamentInput {
  createdBy: UserCreateOneWithoutRoundsInput
  id: ID
  matches: MatchCreateManyInput
  players: PlayerCreateManyWithoutRoundsInput
  roundType: RoundsType!
}

type RoundEdge {
  node: Round!
  cursor: String!
}

enum RoundOrderByInput {
  id_ASC
  id_DESC
  roundType_ASC
  roundType_DESC
}

type RoundPreviousValues {
  id: ID!
  roundType: RoundsType!
}

input RoundScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  roundType: RoundsType
  roundType_not: RoundsType
  roundType_in: [RoundsType!]
  roundType_not_in: [RoundsType!]
  AND: [RoundScalarWhereInput!]
  OR: [RoundScalarWhereInput!]
  NOT: [RoundScalarWhereInput!]
}

enum RoundsType {
  POULES
  ROUND_OF_64
  ROUND_OF_32
  ROUND_OF_16
  QUARTERFINALS
  SEMIFINALS
  THIRD_PLACE_PLAYOFFS
  FINAL
}

type RoundSubscriptionPayload {
  mutation: MutationType!
  node: Round
  updatedFields: [String!]
  previousValues: RoundPreviousValues
}

input RoundSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoundWhereInput
  AND: [RoundSubscriptionWhereInput!]
  OR: [RoundSubscriptionWhereInput!]
  NOT: [RoundSubscriptionWhereInput!]
}

input RoundUpdateInput {
  createdBy: UserUpdateOneWithoutRoundsInput
  matches: MatchUpdateManyInput
  players: PlayerUpdateManyWithoutRoundsInput
  roundType: RoundsType
  tournament: TournamentUpdateOneRequiredWithoutRoundsInput
}

input RoundUpdateManyDataInput {
  roundType: RoundsType
}

input RoundUpdateManyMutationInput {
  roundType: RoundsType
}

input RoundUpdateManyWithoutCreatedByInput {
  create: [RoundCreateWithoutCreatedByInput!]
  delete: [RoundWhereUniqueInput!]
  connect: [RoundWhereUniqueInput!]
  set: [RoundWhereUniqueInput!]
  disconnect: [RoundWhereUniqueInput!]
  update: [RoundUpdateWithWhereUniqueWithoutCreatedByInput!]
  upsert: [RoundUpsertWithWhereUniqueWithoutCreatedByInput!]
  deleteMany: [RoundScalarWhereInput!]
  updateMany: [RoundUpdateManyWithWhereNestedInput!]
}

input RoundUpdateManyWithoutPlayersInput {
  create: [RoundCreateWithoutPlayersInput!]
  delete: [RoundWhereUniqueInput!]
  connect: [RoundWhereUniqueInput!]
  set: [RoundWhereUniqueInput!]
  disconnect: [RoundWhereUniqueInput!]
  update: [RoundUpdateWithWhereUniqueWithoutPlayersInput!]
  upsert: [RoundUpsertWithWhereUniqueWithoutPlayersInput!]
  deleteMany: [RoundScalarWhereInput!]
  updateMany: [RoundUpdateManyWithWhereNestedInput!]
}

input RoundUpdateManyWithoutTournamentInput {
  create: [RoundCreateWithoutTournamentInput!]
  delete: [RoundWhereUniqueInput!]
  connect: [RoundWhereUniqueInput!]
  set: [RoundWhereUniqueInput!]
  disconnect: [RoundWhereUniqueInput!]
  update: [RoundUpdateWithWhereUniqueWithoutTournamentInput!]
  upsert: [RoundUpsertWithWhereUniqueWithoutTournamentInput!]
  deleteMany: [RoundScalarWhereInput!]
  updateMany: [RoundUpdateManyWithWhereNestedInput!]
}

input RoundUpdateManyWithWhereNestedInput {
  where: RoundScalarWhereInput!
  data: RoundUpdateManyDataInput!
}

input RoundUpdateWithoutCreatedByDataInput {
  matches: MatchUpdateManyInput
  players: PlayerUpdateManyWithoutRoundsInput
  roundType: RoundsType
  tournament: TournamentUpdateOneRequiredWithoutRoundsInput
}

input RoundUpdateWithoutPlayersDataInput {
  createdBy: UserUpdateOneWithoutRoundsInput
  matches: MatchUpdateManyInput
  roundType: RoundsType
  tournament: TournamentUpdateOneRequiredWithoutRoundsInput
}

input RoundUpdateWithoutTournamentDataInput {
  createdBy: UserUpdateOneWithoutRoundsInput
  matches: MatchUpdateManyInput
  players: PlayerUpdateManyWithoutRoundsInput
  roundType: RoundsType
}

input RoundUpdateWithWhereUniqueWithoutCreatedByInput {
  where: RoundWhereUniqueInput!
  data: RoundUpdateWithoutCreatedByDataInput!
}

input RoundUpdateWithWhereUniqueWithoutPlayersInput {
  where: RoundWhereUniqueInput!
  data: RoundUpdateWithoutPlayersDataInput!
}

input RoundUpdateWithWhereUniqueWithoutTournamentInput {
  where: RoundWhereUniqueInput!
  data: RoundUpdateWithoutTournamentDataInput!
}

input RoundUpsertWithWhereUniqueWithoutCreatedByInput {
  where: RoundWhereUniqueInput!
  update: RoundUpdateWithoutCreatedByDataInput!
  create: RoundCreateWithoutCreatedByInput!
}

input RoundUpsertWithWhereUniqueWithoutPlayersInput {
  where: RoundWhereUniqueInput!
  update: RoundUpdateWithoutPlayersDataInput!
  create: RoundCreateWithoutPlayersInput!
}

input RoundUpsertWithWhereUniqueWithoutTournamentInput {
  where: RoundWhereUniqueInput!
  update: RoundUpdateWithoutTournamentDataInput!
  create: RoundCreateWithoutTournamentInput!
}

input RoundWhereInput {
  createdBy: UserWhereInput
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  matches_every: MatchWhereInput
  matches_some: MatchWhereInput
  matches_none: MatchWhereInput
  players_every: PlayerWhereInput
  players_some: PlayerWhereInput
  players_none: PlayerWhereInput
  roundType: RoundsType
  roundType_not: RoundsType
  roundType_in: [RoundsType!]
  roundType_not_in: [RoundsType!]
  tournament: TournamentWhereInput
  AND: [RoundWhereInput!]
  OR: [RoundWhereInput!]
  NOT: [RoundWhereInput!]
}

input RoundWhereUniqueInput {
  id: ID
}

type School {
  academy: Academy!
  clans(where: ClanWhereInput, orderBy: ClanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Clan!]
  createdBy: User
  id: ID!
  name: String!
}

type SchoolConnection {
  pageInfo: PageInfo!
  edges: [SchoolEdge]!
  aggregate: AggregateSchool!
}

input SchoolCreateInput {
  academy: AcademyCreateOneWithoutSchoolsInput!
  clans: ClanCreateManyWithoutSchoolInput
  createdBy: UserCreateOneWithoutSchoolsInput
  id: ID
  name: String!
}

input SchoolCreateManyWithoutAcademyInput {
  create: [SchoolCreateWithoutAcademyInput!]
  connect: [SchoolWhereUniqueInput!]
}

input SchoolCreateManyWithoutCreatedByInput {
  create: [SchoolCreateWithoutCreatedByInput!]
  connect: [SchoolWhereUniqueInput!]
}

input SchoolCreateOneWithoutClansInput {
  create: SchoolCreateWithoutClansInput
  connect: SchoolWhereUniqueInput
}

input SchoolCreateWithoutAcademyInput {
  clans: ClanCreateManyWithoutSchoolInput
  createdBy: UserCreateOneWithoutSchoolsInput
  id: ID
  name: String!
}

input SchoolCreateWithoutClansInput {
  academy: AcademyCreateOneWithoutSchoolsInput!
  createdBy: UserCreateOneWithoutSchoolsInput
  id: ID
  name: String!
}

input SchoolCreateWithoutCreatedByInput {
  academy: AcademyCreateOneWithoutSchoolsInput!
  clans: ClanCreateManyWithoutSchoolInput
  id: ID
  name: String!
}

type SchoolEdge {
  node: School!
  cursor: String!
}

enum SchoolOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type SchoolPreviousValues {
  id: ID!
  name: String!
}

input SchoolScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [SchoolScalarWhereInput!]
  OR: [SchoolScalarWhereInput!]
  NOT: [SchoolScalarWhereInput!]
}

type SchoolSubscriptionPayload {
  mutation: MutationType!
  node: School
  updatedFields: [String!]
  previousValues: SchoolPreviousValues
}

input SchoolSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SchoolWhereInput
  AND: [SchoolSubscriptionWhereInput!]
  OR: [SchoolSubscriptionWhereInput!]
  NOT: [SchoolSubscriptionWhereInput!]
}

input SchoolUpdateInput {
  academy: AcademyUpdateOneRequiredWithoutSchoolsInput
  clans: ClanUpdateManyWithoutSchoolInput
  createdBy: UserUpdateOneWithoutSchoolsInput
  name: String
}

input SchoolUpdateManyDataInput {
  name: String
}

input SchoolUpdateManyMutationInput {
  name: String
}

input SchoolUpdateManyWithoutAcademyInput {
  create: [SchoolCreateWithoutAcademyInput!]
  delete: [SchoolWhereUniqueInput!]
  connect: [SchoolWhereUniqueInput!]
  set: [SchoolWhereUniqueInput!]
  disconnect: [SchoolWhereUniqueInput!]
  update: [SchoolUpdateWithWhereUniqueWithoutAcademyInput!]
  upsert: [SchoolUpsertWithWhereUniqueWithoutAcademyInput!]
  deleteMany: [SchoolScalarWhereInput!]
  updateMany: [SchoolUpdateManyWithWhereNestedInput!]
}

input SchoolUpdateManyWithoutCreatedByInput {
  create: [SchoolCreateWithoutCreatedByInput!]
  delete: [SchoolWhereUniqueInput!]
  connect: [SchoolWhereUniqueInput!]
  set: [SchoolWhereUniqueInput!]
  disconnect: [SchoolWhereUniqueInput!]
  update: [SchoolUpdateWithWhereUniqueWithoutCreatedByInput!]
  upsert: [SchoolUpsertWithWhereUniqueWithoutCreatedByInput!]
  deleteMany: [SchoolScalarWhereInput!]
  updateMany: [SchoolUpdateManyWithWhereNestedInput!]
}

input SchoolUpdateManyWithWhereNestedInput {
  where: SchoolScalarWhereInput!
  data: SchoolUpdateManyDataInput!
}

input SchoolUpdateOneRequiredWithoutClansInput {
  create: SchoolCreateWithoutClansInput
  update: SchoolUpdateWithoutClansDataInput
  upsert: SchoolUpsertWithoutClansInput
  connect: SchoolWhereUniqueInput
}

input SchoolUpdateWithoutAcademyDataInput {
  clans: ClanUpdateManyWithoutSchoolInput
  createdBy: UserUpdateOneWithoutSchoolsInput
  name: String
}

input SchoolUpdateWithoutClansDataInput {
  academy: AcademyUpdateOneRequiredWithoutSchoolsInput
  createdBy: UserUpdateOneWithoutSchoolsInput
  name: String
}

input SchoolUpdateWithoutCreatedByDataInput {
  academy: AcademyUpdateOneRequiredWithoutSchoolsInput
  clans: ClanUpdateManyWithoutSchoolInput
  name: String
}

input SchoolUpdateWithWhereUniqueWithoutAcademyInput {
  where: SchoolWhereUniqueInput!
  data: SchoolUpdateWithoutAcademyDataInput!
}

input SchoolUpdateWithWhereUniqueWithoutCreatedByInput {
  where: SchoolWhereUniqueInput!
  data: SchoolUpdateWithoutCreatedByDataInput!
}

input SchoolUpsertWithoutClansInput {
  update: SchoolUpdateWithoutClansDataInput!
  create: SchoolCreateWithoutClansInput!
}

input SchoolUpsertWithWhereUniqueWithoutAcademyInput {
  where: SchoolWhereUniqueInput!
  update: SchoolUpdateWithoutAcademyDataInput!
  create: SchoolCreateWithoutAcademyInput!
}

input SchoolUpsertWithWhereUniqueWithoutCreatedByInput {
  where: SchoolWhereUniqueInput!
  update: SchoolUpdateWithoutCreatedByDataInput!
  create: SchoolCreateWithoutCreatedByInput!
}

input SchoolWhereInput {
  academy: AcademyWhereInput
  clans_every: ClanWhereInput
  clans_some: ClanWhereInput
  clans_none: ClanWhereInput
  createdBy: UserWhereInput
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [SchoolWhereInput!]
  OR: [SchoolWhereInput!]
  NOT: [SchoolWhereInput!]
}

input SchoolWhereUniqueInput {
  id: ID
}

type Subscription {
  academy(where: AcademySubscriptionWhereInput): AcademySubscriptionPayload
  assault(where: AssaultSubscriptionWhereInput): AssaultSubscriptionPayload
  card(where: CardSubscriptionWhereInput): CardSubscriptionPayload
  clan(where: ClanSubscriptionWhereInput): ClanSubscriptionPayload
  form(where: FormSubscriptionWhereInput): FormSubscriptionPayload
  match(where: MatchSubscriptionWhereInput): MatchSubscriptionPayload
  player(where: PlayerSubscriptionWhereInput): PlayerSubscriptionPayload
  poule(where: PouleSubscriptionWhereInput): PouleSubscriptionPayload
  round(where: RoundSubscriptionWhereInput): RoundSubscriptionPayload
  school(where: SchoolSubscriptionWhereInput): SchoolSubscriptionPayload
  tournament(where: TournamentSubscriptionWhereInput): TournamentSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Tournament {
  createdBy: User
  currentRound: RoundsType
  id: ID!
  name: String!
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player!]
  poulesType: PoulesType!
  poules(where: PouleWhereInput, orderBy: PouleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Poule!]
  rounds(where: RoundWhereInput, orderBy: RoundOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Round!]
}

type TournamentConnection {
  pageInfo: PageInfo!
  edges: [TournamentEdge]!
  aggregate: AggregateTournament!
}

input TournamentCreateInput {
  createdBy: UserCreateOneWithoutTournamentsInput
  currentRound: RoundsType
  id: ID
  name: String!
  players: PlayerCreateManyWithoutTournamentsInput
  poulesType: PoulesType!
  poules: PouleCreateManyWithoutTournamentInput
  rounds: RoundCreateManyWithoutTournamentInput
}

input TournamentCreateManyWithoutCreatedByInput {
  create: [TournamentCreateWithoutCreatedByInput!]
  connect: [TournamentWhereUniqueInput!]
}

input TournamentCreateManyWithoutPlayersInput {
  create: [TournamentCreateWithoutPlayersInput!]
  connect: [TournamentWhereUniqueInput!]
}

input TournamentCreateOneWithoutPoulesInput {
  create: TournamentCreateWithoutPoulesInput
  connect: TournamentWhereUniqueInput
}

input TournamentCreateOneWithoutRoundsInput {
  create: TournamentCreateWithoutRoundsInput
  connect: TournamentWhereUniqueInput
}

input TournamentCreateWithoutCreatedByInput {
  currentRound: RoundsType
  id: ID
  name: String!
  players: PlayerCreateManyWithoutTournamentsInput
  poulesType: PoulesType!
  poules: PouleCreateManyWithoutTournamentInput
  rounds: RoundCreateManyWithoutTournamentInput
}

input TournamentCreateWithoutPlayersInput {
  createdBy: UserCreateOneWithoutTournamentsInput
  currentRound: RoundsType
  id: ID
  name: String!
  poulesType: PoulesType!
  poules: PouleCreateManyWithoutTournamentInput
  rounds: RoundCreateManyWithoutTournamentInput
}

input TournamentCreateWithoutPoulesInput {
  createdBy: UserCreateOneWithoutTournamentsInput
  currentRound: RoundsType
  id: ID
  name: String!
  players: PlayerCreateManyWithoutTournamentsInput
  poulesType: PoulesType!
  rounds: RoundCreateManyWithoutTournamentInput
}

input TournamentCreateWithoutRoundsInput {
  createdBy: UserCreateOneWithoutTournamentsInput
  currentRound: RoundsType
  id: ID
  name: String!
  players: PlayerCreateManyWithoutTournamentsInput
  poulesType: PoulesType!
  poules: PouleCreateManyWithoutTournamentInput
}

type TournamentEdge {
  node: Tournament!
  cursor: String!
}

enum TournamentOrderByInput {
  currentRound_ASC
  currentRound_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  poulesType_ASC
  poulesType_DESC
}

type TournamentPreviousValues {
  currentRound: RoundsType
  id: ID!
  name: String!
  poulesType: PoulesType!
}

input TournamentScalarWhereInput {
  currentRound: RoundsType
  currentRound_not: RoundsType
  currentRound_in: [RoundsType!]
  currentRound_not_in: [RoundsType!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  poulesType: PoulesType
  poulesType_not: PoulesType
  poulesType_in: [PoulesType!]
  poulesType_not_in: [PoulesType!]
  AND: [TournamentScalarWhereInput!]
  OR: [TournamentScalarWhereInput!]
  NOT: [TournamentScalarWhereInput!]
}

type TournamentSubscriptionPayload {
  mutation: MutationType!
  node: Tournament
  updatedFields: [String!]
  previousValues: TournamentPreviousValues
}

input TournamentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TournamentWhereInput
  AND: [TournamentSubscriptionWhereInput!]
  OR: [TournamentSubscriptionWhereInput!]
  NOT: [TournamentSubscriptionWhereInput!]
}

input TournamentUpdateInput {
  createdBy: UserUpdateOneWithoutTournamentsInput
  currentRound: RoundsType
  name: String
  players: PlayerUpdateManyWithoutTournamentsInput
  poulesType: PoulesType
  poules: PouleUpdateManyWithoutTournamentInput
  rounds: RoundUpdateManyWithoutTournamentInput
}

input TournamentUpdateManyDataInput {
  currentRound: RoundsType
  name: String
  poulesType: PoulesType
}

input TournamentUpdateManyMutationInput {
  currentRound: RoundsType
  name: String
  poulesType: PoulesType
}

input TournamentUpdateManyWithoutCreatedByInput {
  create: [TournamentCreateWithoutCreatedByInput!]
  delete: [TournamentWhereUniqueInput!]
  connect: [TournamentWhereUniqueInput!]
  set: [TournamentWhereUniqueInput!]
  disconnect: [TournamentWhereUniqueInput!]
  update: [TournamentUpdateWithWhereUniqueWithoutCreatedByInput!]
  upsert: [TournamentUpsertWithWhereUniqueWithoutCreatedByInput!]
  deleteMany: [TournamentScalarWhereInput!]
  updateMany: [TournamentUpdateManyWithWhereNestedInput!]
}

input TournamentUpdateManyWithoutPlayersInput {
  create: [TournamentCreateWithoutPlayersInput!]
  delete: [TournamentWhereUniqueInput!]
  connect: [TournamentWhereUniqueInput!]
  set: [TournamentWhereUniqueInput!]
  disconnect: [TournamentWhereUniqueInput!]
  update: [TournamentUpdateWithWhereUniqueWithoutPlayersInput!]
  upsert: [TournamentUpsertWithWhereUniqueWithoutPlayersInput!]
  deleteMany: [TournamentScalarWhereInput!]
  updateMany: [TournamentUpdateManyWithWhereNestedInput!]
}

input TournamentUpdateManyWithWhereNestedInput {
  where: TournamentScalarWhereInput!
  data: TournamentUpdateManyDataInput!
}

input TournamentUpdateOneRequiredWithoutPoulesInput {
  create: TournamentCreateWithoutPoulesInput
  update: TournamentUpdateWithoutPoulesDataInput
  upsert: TournamentUpsertWithoutPoulesInput
  connect: TournamentWhereUniqueInput
}

input TournamentUpdateOneRequiredWithoutRoundsInput {
  create: TournamentCreateWithoutRoundsInput
  update: TournamentUpdateWithoutRoundsDataInput
  upsert: TournamentUpsertWithoutRoundsInput
  connect: TournamentWhereUniqueInput
}

input TournamentUpdateWithoutCreatedByDataInput {
  currentRound: RoundsType
  name: String
  players: PlayerUpdateManyWithoutTournamentsInput
  poulesType: PoulesType
  poules: PouleUpdateManyWithoutTournamentInput
  rounds: RoundUpdateManyWithoutTournamentInput
}

input TournamentUpdateWithoutPlayersDataInput {
  createdBy: UserUpdateOneWithoutTournamentsInput
  currentRound: RoundsType
  name: String
  poulesType: PoulesType
  poules: PouleUpdateManyWithoutTournamentInput
  rounds: RoundUpdateManyWithoutTournamentInput
}

input TournamentUpdateWithoutPoulesDataInput {
  createdBy: UserUpdateOneWithoutTournamentsInput
  currentRound: RoundsType
  name: String
  players: PlayerUpdateManyWithoutTournamentsInput
  poulesType: PoulesType
  rounds: RoundUpdateManyWithoutTournamentInput
}

input TournamentUpdateWithoutRoundsDataInput {
  createdBy: UserUpdateOneWithoutTournamentsInput
  currentRound: RoundsType
  name: String
  players: PlayerUpdateManyWithoutTournamentsInput
  poulesType: PoulesType
  poules: PouleUpdateManyWithoutTournamentInput
}

input TournamentUpdateWithWhereUniqueWithoutCreatedByInput {
  where: TournamentWhereUniqueInput!
  data: TournamentUpdateWithoutCreatedByDataInput!
}

input TournamentUpdateWithWhereUniqueWithoutPlayersInput {
  where: TournamentWhereUniqueInput!
  data: TournamentUpdateWithoutPlayersDataInput!
}

input TournamentUpsertWithoutPoulesInput {
  update: TournamentUpdateWithoutPoulesDataInput!
  create: TournamentCreateWithoutPoulesInput!
}

input TournamentUpsertWithoutRoundsInput {
  update: TournamentUpdateWithoutRoundsDataInput!
  create: TournamentCreateWithoutRoundsInput!
}

input TournamentUpsertWithWhereUniqueWithoutCreatedByInput {
  where: TournamentWhereUniqueInput!
  update: TournamentUpdateWithoutCreatedByDataInput!
  create: TournamentCreateWithoutCreatedByInput!
}

input TournamentUpsertWithWhereUniqueWithoutPlayersInput {
  where: TournamentWhereUniqueInput!
  update: TournamentUpdateWithoutPlayersDataInput!
  create: TournamentCreateWithoutPlayersInput!
}

input TournamentWhereInput {
  createdBy: UserWhereInput
  currentRound: RoundsType
  currentRound_not: RoundsType
  currentRound_in: [RoundsType!]
  currentRound_not_in: [RoundsType!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  players_every: PlayerWhereInput
  players_some: PlayerWhereInput
  players_none: PlayerWhereInput
  poulesType: PoulesType
  poulesType_not: PoulesType
  poulesType_in: [PoulesType!]
  poulesType_not_in: [PoulesType!]
  poules_every: PouleWhereInput
  poules_some: PouleWhereInput
  poules_none: PouleWhereInput
  rounds_every: RoundWhereInput
  rounds_some: RoundWhereInput
  rounds_none: RoundWhereInput
  AND: [TournamentWhereInput!]
  OR: [TournamentWhereInput!]
  NOT: [TournamentWhereInput!]
}

input TournamentWhereUniqueInput {
  id: ID
}

type User {
  academies(where: AcademyWhereInput, orderBy: AcademyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Academy!]
  clans(where: ClanWhereInput, orderBy: ClanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Clan!]
  email: String!
  forms(where: FormWhereInput, orderBy: FormOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Form!]
  id: ID!
  name: String!
  password: String!
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player!]
  poules(where: PouleWhereInput, orderBy: PouleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Poule!]
  rounds(where: RoundWhereInput, orderBy: RoundOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Round!]
  schools(where: SchoolWhereInput, orderBy: SchoolOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [School!]
  tournaments(where: TournamentWhereInput, orderBy: TournamentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tournament!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  academies: AcademyCreateManyWithoutCreatedByInput
  clans: ClanCreateManyWithoutCreatedByInput
  email: String!
  forms: FormCreateManyWithoutCreatedByInput
  id: ID
  name: String!
  password: String!
  players: PlayerCreateManyWithoutCreatedByInput
  poules: PouleCreateManyWithoutCreatedByInput
  rounds: RoundCreateManyWithoutCreatedByInput
  schools: SchoolCreateManyWithoutCreatedByInput
  tournaments: TournamentCreateManyWithoutCreatedByInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutAcademiesInput {
  create: UserCreateWithoutAcademiesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutClansInput {
  create: UserCreateWithoutClansInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutFormsInput {
  create: UserCreateWithoutFormsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPlayersInput {
  create: UserCreateWithoutPlayersInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPoulesInput {
  create: UserCreateWithoutPoulesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutRoundsInput {
  create: UserCreateWithoutRoundsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutSchoolsInput {
  create: UserCreateWithoutSchoolsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutTournamentsInput {
  create: UserCreateWithoutTournamentsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAcademiesInput {
  clans: ClanCreateManyWithoutCreatedByInput
  email: String!
  forms: FormCreateManyWithoutCreatedByInput
  id: ID
  name: String!
  password: String!
  players: PlayerCreateManyWithoutCreatedByInput
  poules: PouleCreateManyWithoutCreatedByInput
  rounds: RoundCreateManyWithoutCreatedByInput
  schools: SchoolCreateManyWithoutCreatedByInput
  tournaments: TournamentCreateManyWithoutCreatedByInput
}

input UserCreateWithoutClansInput {
  academies: AcademyCreateManyWithoutCreatedByInput
  email: String!
  forms: FormCreateManyWithoutCreatedByInput
  id: ID
  name: String!
  password: String!
  players: PlayerCreateManyWithoutCreatedByInput
  poules: PouleCreateManyWithoutCreatedByInput
  rounds: RoundCreateManyWithoutCreatedByInput
  schools: SchoolCreateManyWithoutCreatedByInput
  tournaments: TournamentCreateManyWithoutCreatedByInput
}

input UserCreateWithoutFormsInput {
  academies: AcademyCreateManyWithoutCreatedByInput
  clans: ClanCreateManyWithoutCreatedByInput
  email: String!
  id: ID
  name: String!
  password: String!
  players: PlayerCreateManyWithoutCreatedByInput
  poules: PouleCreateManyWithoutCreatedByInput
  rounds: RoundCreateManyWithoutCreatedByInput
  schools: SchoolCreateManyWithoutCreatedByInput
  tournaments: TournamentCreateManyWithoutCreatedByInput
}

input UserCreateWithoutPlayersInput {
  academies: AcademyCreateManyWithoutCreatedByInput
  clans: ClanCreateManyWithoutCreatedByInput
  email: String!
  forms: FormCreateManyWithoutCreatedByInput
  id: ID
  name: String!
  password: String!
  poules: PouleCreateManyWithoutCreatedByInput
  rounds: RoundCreateManyWithoutCreatedByInput
  schools: SchoolCreateManyWithoutCreatedByInput
  tournaments: TournamentCreateManyWithoutCreatedByInput
}

input UserCreateWithoutPoulesInput {
  academies: AcademyCreateManyWithoutCreatedByInput
  clans: ClanCreateManyWithoutCreatedByInput
  email: String!
  forms: FormCreateManyWithoutCreatedByInput
  id: ID
  name: String!
  password: String!
  players: PlayerCreateManyWithoutCreatedByInput
  rounds: RoundCreateManyWithoutCreatedByInput
  schools: SchoolCreateManyWithoutCreatedByInput
  tournaments: TournamentCreateManyWithoutCreatedByInput
}

input UserCreateWithoutRoundsInput {
  academies: AcademyCreateManyWithoutCreatedByInput
  clans: ClanCreateManyWithoutCreatedByInput
  email: String!
  forms: FormCreateManyWithoutCreatedByInput
  id: ID
  name: String!
  password: String!
  players: PlayerCreateManyWithoutCreatedByInput
  poules: PouleCreateManyWithoutCreatedByInput
  schools: SchoolCreateManyWithoutCreatedByInput
  tournaments: TournamentCreateManyWithoutCreatedByInput
}

input UserCreateWithoutSchoolsInput {
  academies: AcademyCreateManyWithoutCreatedByInput
  clans: ClanCreateManyWithoutCreatedByInput
  email: String!
  forms: FormCreateManyWithoutCreatedByInput
  id: ID
  name: String!
  password: String!
  players: PlayerCreateManyWithoutCreatedByInput
  poules: PouleCreateManyWithoutCreatedByInput
  rounds: RoundCreateManyWithoutCreatedByInput
  tournaments: TournamentCreateManyWithoutCreatedByInput
}

input UserCreateWithoutTournamentsInput {
  academies: AcademyCreateManyWithoutCreatedByInput
  clans: ClanCreateManyWithoutCreatedByInput
  email: String!
  forms: FormCreateManyWithoutCreatedByInput
  id: ID
  name: String!
  password: String!
  players: PlayerCreateManyWithoutCreatedByInput
  poules: PouleCreateManyWithoutCreatedByInput
  rounds: RoundCreateManyWithoutCreatedByInput
  schools: SchoolCreateManyWithoutCreatedByInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  email_ASC
  email_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  email: String!
  id: ID!
  name: String!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  academies: AcademyUpdateManyWithoutCreatedByInput
  clans: ClanUpdateManyWithoutCreatedByInput
  email: String
  forms: FormUpdateManyWithoutCreatedByInput
  name: String
  password: String
  players: PlayerUpdateManyWithoutCreatedByInput
  poules: PouleUpdateManyWithoutCreatedByInput
  rounds: RoundUpdateManyWithoutCreatedByInput
  schools: SchoolUpdateManyWithoutCreatedByInput
  tournaments: TournamentUpdateManyWithoutCreatedByInput
}

input UserUpdateInput {
  academies: AcademyUpdateManyWithoutCreatedByInput
  clans: ClanUpdateManyWithoutCreatedByInput
  email: String
  forms: FormUpdateManyWithoutCreatedByInput
  name: String
  password: String
  players: PlayerUpdateManyWithoutCreatedByInput
  poules: PouleUpdateManyWithoutCreatedByInput
  rounds: RoundUpdateManyWithoutCreatedByInput
  schools: SchoolUpdateManyWithoutCreatedByInput
  tournaments: TournamentUpdateManyWithoutCreatedByInput
}

input UserUpdateManyMutationInput {
  email: String
  name: String
  password: String
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutAcademiesInput {
  create: UserCreateWithoutAcademiesInput
  update: UserUpdateWithoutAcademiesDataInput
  upsert: UserUpsertWithoutAcademiesInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutClansInput {
  create: UserCreateWithoutClansInput
  update: UserUpdateWithoutClansDataInput
  upsert: UserUpsertWithoutClansInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutFormsInput {
  create: UserCreateWithoutFormsInput
  update: UserUpdateWithoutFormsDataInput
  upsert: UserUpsertWithoutFormsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutPlayersInput {
  create: UserCreateWithoutPlayersInput
  update: UserUpdateWithoutPlayersDataInput
  upsert: UserUpsertWithoutPlayersInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutPoulesInput {
  create: UserCreateWithoutPoulesInput
  update: UserUpdateWithoutPoulesDataInput
  upsert: UserUpsertWithoutPoulesInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutRoundsInput {
  create: UserCreateWithoutRoundsInput
  update: UserUpdateWithoutRoundsDataInput
  upsert: UserUpsertWithoutRoundsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutSchoolsInput {
  create: UserCreateWithoutSchoolsInput
  update: UserUpdateWithoutSchoolsDataInput
  upsert: UserUpsertWithoutSchoolsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutTournamentsInput {
  create: UserCreateWithoutTournamentsInput
  update: UserUpdateWithoutTournamentsDataInput
  upsert: UserUpsertWithoutTournamentsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutAcademiesDataInput {
  clans: ClanUpdateManyWithoutCreatedByInput
  email: String
  forms: FormUpdateManyWithoutCreatedByInput
  name: String
  password: String
  players: PlayerUpdateManyWithoutCreatedByInput
  poules: PouleUpdateManyWithoutCreatedByInput
  rounds: RoundUpdateManyWithoutCreatedByInput
  schools: SchoolUpdateManyWithoutCreatedByInput
  tournaments: TournamentUpdateManyWithoutCreatedByInput
}

input UserUpdateWithoutClansDataInput {
  academies: AcademyUpdateManyWithoutCreatedByInput
  email: String
  forms: FormUpdateManyWithoutCreatedByInput
  name: String
  password: String
  players: PlayerUpdateManyWithoutCreatedByInput
  poules: PouleUpdateManyWithoutCreatedByInput
  rounds: RoundUpdateManyWithoutCreatedByInput
  schools: SchoolUpdateManyWithoutCreatedByInput
  tournaments: TournamentUpdateManyWithoutCreatedByInput
}

input UserUpdateWithoutFormsDataInput {
  academies: AcademyUpdateManyWithoutCreatedByInput
  clans: ClanUpdateManyWithoutCreatedByInput
  email: String
  name: String
  password: String
  players: PlayerUpdateManyWithoutCreatedByInput
  poules: PouleUpdateManyWithoutCreatedByInput
  rounds: RoundUpdateManyWithoutCreatedByInput
  schools: SchoolUpdateManyWithoutCreatedByInput
  tournaments: TournamentUpdateManyWithoutCreatedByInput
}

input UserUpdateWithoutPlayersDataInput {
  academies: AcademyUpdateManyWithoutCreatedByInput
  clans: ClanUpdateManyWithoutCreatedByInput
  email: String
  forms: FormUpdateManyWithoutCreatedByInput
  name: String
  password: String
  poules: PouleUpdateManyWithoutCreatedByInput
  rounds: RoundUpdateManyWithoutCreatedByInput
  schools: SchoolUpdateManyWithoutCreatedByInput
  tournaments: TournamentUpdateManyWithoutCreatedByInput
}

input UserUpdateWithoutPoulesDataInput {
  academies: AcademyUpdateManyWithoutCreatedByInput
  clans: ClanUpdateManyWithoutCreatedByInput
  email: String
  forms: FormUpdateManyWithoutCreatedByInput
  name: String
  password: String
  players: PlayerUpdateManyWithoutCreatedByInput
  rounds: RoundUpdateManyWithoutCreatedByInput
  schools: SchoolUpdateManyWithoutCreatedByInput
  tournaments: TournamentUpdateManyWithoutCreatedByInput
}

input UserUpdateWithoutRoundsDataInput {
  academies: AcademyUpdateManyWithoutCreatedByInput
  clans: ClanUpdateManyWithoutCreatedByInput
  email: String
  forms: FormUpdateManyWithoutCreatedByInput
  name: String
  password: String
  players: PlayerUpdateManyWithoutCreatedByInput
  poules: PouleUpdateManyWithoutCreatedByInput
  schools: SchoolUpdateManyWithoutCreatedByInput
  tournaments: TournamentUpdateManyWithoutCreatedByInput
}

input UserUpdateWithoutSchoolsDataInput {
  academies: AcademyUpdateManyWithoutCreatedByInput
  clans: ClanUpdateManyWithoutCreatedByInput
  email: String
  forms: FormUpdateManyWithoutCreatedByInput
  name: String
  password: String
  players: PlayerUpdateManyWithoutCreatedByInput
  poules: PouleUpdateManyWithoutCreatedByInput
  rounds: RoundUpdateManyWithoutCreatedByInput
  tournaments: TournamentUpdateManyWithoutCreatedByInput
}

input UserUpdateWithoutTournamentsDataInput {
  academies: AcademyUpdateManyWithoutCreatedByInput
  clans: ClanUpdateManyWithoutCreatedByInput
  email: String
  forms: FormUpdateManyWithoutCreatedByInput
  name: String
  password: String
  players: PlayerUpdateManyWithoutCreatedByInput
  poules: PouleUpdateManyWithoutCreatedByInput
  rounds: RoundUpdateManyWithoutCreatedByInput
  schools: SchoolUpdateManyWithoutCreatedByInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutAcademiesInput {
  update: UserUpdateWithoutAcademiesDataInput!
  create: UserCreateWithoutAcademiesInput!
}

input UserUpsertWithoutClansInput {
  update: UserUpdateWithoutClansDataInput!
  create: UserCreateWithoutClansInput!
}

input UserUpsertWithoutFormsInput {
  update: UserUpdateWithoutFormsDataInput!
  create: UserCreateWithoutFormsInput!
}

input UserUpsertWithoutPlayersInput {
  update: UserUpdateWithoutPlayersDataInput!
  create: UserCreateWithoutPlayersInput!
}

input UserUpsertWithoutPoulesInput {
  update: UserUpdateWithoutPoulesDataInput!
  create: UserCreateWithoutPoulesInput!
}

input UserUpsertWithoutRoundsInput {
  update: UserUpdateWithoutRoundsDataInput!
  create: UserCreateWithoutRoundsInput!
}

input UserUpsertWithoutSchoolsInput {
  update: UserUpdateWithoutSchoolsDataInput!
  create: UserCreateWithoutSchoolsInput!
}

input UserUpsertWithoutTournamentsInput {
  update: UserUpdateWithoutTournamentsDataInput!
  create: UserCreateWithoutTournamentsInput!
}

input UserWhereInput {
  academies_every: AcademyWhereInput
  academies_some: AcademyWhereInput
  academies_none: AcademyWhereInput
  clans_every: ClanWhereInput
  clans_some: ClanWhereInput
  clans_none: ClanWhereInput
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  forms_every: FormWhereInput
  forms_some: FormWhereInput
  forms_none: FormWhereInput
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  players_every: PlayerWhereInput
  players_some: PlayerWhereInput
  players_none: PlayerWhereInput
  poules_every: PouleWhereInput
  poules_some: PouleWhereInput
  poules_none: PouleWhereInput
  rounds_every: RoundWhereInput
  rounds_some: RoundWhereInput
  rounds_none: RoundWhereInput
  schools_every: SchoolWhereInput
  schools_some: SchoolWhereInput
  schools_none: SchoolWhereInput
  tournaments_every: TournamentWhereInput
  tournaments_some: TournamentWhereInput
  tournaments_none: TournamentWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  email: String
  id: ID
}
`
      }
    